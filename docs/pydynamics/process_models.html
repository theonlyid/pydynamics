<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pydynamics.process_models API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pydynamics.process_models</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import matplotlib.pyplot as plt
from collections import namedtuple

from scipy.integrate import odeint
from scipy.optimize import minimize
from scipy.interpolate import interp1d

#TODO: Generate Results class with named tuples

Data = namedtuple(&#34;Data&#34;, [&#34;ts&#34;, &#34;y&#34;, &#34;u&#34;])
Params = namedtuple(&#34;Params&#34;, [&#34;K&#34;, &#34;tau&#34;, &#34;theta&#34;, &#34;zeta&#34;])
Result = namedtuple(&#34;Result&#34;, [&#34;p_opt&#34;, &#34;p_cov&#34;, &#34;r_square&#34;, &#34;y_hat&#34;, &#34;resid&#34;])

class ProcessModel:
  &#34;Base model class that handles the fitting and plotting for various process models&#34;

  def __init__(self, t, y, u):
    self.t = t
    self.y = y
    self.u = u
    self.uf = interp1d(t, u)

  def objective(self, params):
    ym = self.simulate(params)
    return np.sum((ym -self.y)**2)

  def fit_params(self, init_guess=None):
    if init_guess is None:
      init_guess = np.ones(self.params.shape)
    solution = minimize(self.objective, init_guess, bounds=self.bounds)
    p_opt = solution.x
    return p_opt
  
  def fit_model(self, plot_result=False):
    result = dict()
    result[&#34;soln&#34;] = self.fit_params()
    result[&#34;y_pred&#34;] = self.simulate(result[&#34;soln&#34;])
    result[&#34;mse&#34;] = self.objective(result[&#34;soln&#34;])/len(self.y)
    result[&#34;R2&#34;] = 1 - (np.var(self.y - result[&#34;y_pred&#34;])/np.var(self.y))
    self.result = result
  
    if plot_result:
      self.plot_results()

    self.result = result
    return result

  def step(self, params=None, step=1):
    &#34;&#34;&#34;
    Generate a step response plot for a FOPDT model with the given params
    &#34;&#34;&#34;
    if params is None:
      params = self.result[&#34;soln&#34;]
    taum = params[1]
    ts = np.arange(-taum, 5*taum)

    us = np.zeros((len(ts)))
    us[np.int8(taum)+1:] = step

    y = self.simulate(params, ts, us)
    plt.figure()
    plt.subplots(2,1, sharex=True)

    plt.subplot(211)
    plt.plot(ts, y)
    plt.grid()
    plt.ylabel(&#34;Output&#34;)
    plt.subplot(212)
    plt.ylabel(&#34;Input&#34;)
    plt.plot(ts, us)
    plt.grid()

  def plot_results(self):
    plt.subplots(2,1, sharex=True)
    plt.suptitle(&#34;model fit&#34;)
    
    plt.subplot(211)
    plt.plot(self.t, self.y, linewidth=2)
    plt.plot(self.t, self.result[&#34;y_pred&#34;], &#39;k--&#39;)
    plt.grid()
    plt.title(&#34;Output&#34;)
    plt.ylabel(&#34;Change in output&#34;)
    plt.legend([&#34;data&#34;, &#34;model&#34;])

    plt.subplot(212)
    plt.plot(self.t, self.u)
    plt.grid()
    plt.title(&#34;Input&#34;)
    plt.xlabel(&#34;time&#34;)
    plt.ylabel(&#34;change in input&#34;)

  def diagnostics(self, resid, plot=True):

    t = self.t
    dt = t[1]-t[0]
   
    res_norm = resid/np.linalg.norm(resid)
    u_norm = self.u/np.linalg.norm(self.u)

    resd = np.diff(resid)
    resd_norm = np.diff(resd)/np.linalg.norm(np.diff(resd))

    acf = np.correlate(res_norm, res_norm, &#39;same&#39;)
    acf[len(acf)//2] = 0
    ccf = np.correlate(u_norm, res_norm, &#39;same&#39;)

    acfd = np.correlate(resd_norm, resd_norm, &#39;same&#39;)
    acfd[len(acfd)//2] = 0
    ccfd = np.correlate(u_norm, resd_norm, &#39;same&#39;)

    self.cc_means = dict({&#34;acf&#34;: np.mean(acf**2), &#34;ccf&#34;: np.mean(ccf**2), &#34;acfd&#34;: np.mean(acfd**2), &#34;ccfd&#34;: np.mean(ccfd**2)})

    print(f&#34;{np.mean(acf**2):0.3f}, {np.mean(ccf**2):0.3f}, {np.mean(acfd**2):0.3f}, {np.mean(ccfd**2):0.3f}&#34;)


    if plot:
      plt.subplots(3, 2)
      plt.subplot(321)
      plt.plot(resid)
      plt.title(&#34;Residuals&#34;)
      plt.grid()
      
      plt.subplot(323)
      plt.title(&#34;Autocorrelation of Residuals&#34;)
      plt.plot(acf)
      plt.ylim([-1, 1])
      plt.grid()
      
      plt.subplot(325)
      plt.title(&#34;Cross-correlation: Residuals -&gt; input&#34;)
      plt.plot(ccf)

      plt.ylim([-1,1])
      plt.grid()

      plt.subplot(322)
      plt.plot(resd)
      plt.title(&#34;Residual diff&#34;)
      plt.grid()
      
      plt.subplot(324)
      plt.title(&#34;Autocorrelation of Residual diff&#34;)
      plt.plot(acfd)
      plt.ylim([-1, 1])
      plt.grid()
    
      
      plt.subplot(326)
      plt.title(&#34;Cross-correlation: Residual diff -&gt; input&#34;)
      plt.plot(ccfd)
      plt.ylim([-1,1])
      plt.grid()


class FOPDT(ProcessModel):
  def __init__(self, t, y, u, params=np.ones((3,))):
    super(FOPDT, self).__init__(t, y, u)
    self.params = params
    self.bounds = [(-np.inf, np.inf), (0.1, np.inf), (0., np.inf)]
    
  def model(self, y, t, uf, K, tau, theta):
    try:    
      if t - theta &lt;= 0:
        um = 0
      else:
        um = uf(t - theta)
    except:
      um = 0
    dydt = (-(y) + K*(um))/tau
    return dydt

  def simulate(self, params=None, t=None, u=None):
    if params is None:
      params=self.params
    Km = params[0]
    taum = params[1]
    thetam = params[2]

    if t is None:
      t = self.t
    
    if u is None:
      u = self.u
    
    uf = interp1d(t, u)
    ym = np.zeros(len(t))

    for i in range(0, len(t)-1):
      ts=[t[i], t[i+1]]
      y1 = odeint(self.model, ym[i], ts, args=(uf, Km, taum, thetam))[-1].item()
      ym[i+1] = y1

    return ym


class SOPDT(ProcessModel):
    def __init__(self, t, y, u, params=np.ones((4,))):
        super(SOPDT, self).__init__(t, y, u)
        self.params = params
        self.bounds = [(-np.inf, np.inf), (0.01, np.inf), (0.01, np.inf), (0, np.inf)]

    def model(self, x, t, uf, Kp, taus, zeta, thetap):
    # Kp = process gain
    # taus = second order time constant
    # zeta = damping factor
    # thetap = model time delay
    # equation: ts^2 dy2/dt2 + 2 zeta taus dydt + y = Kp * u(t-thetap)

        u0 = 0
        try:
            if (t-thetap) &lt;= 0:
                um = 0
            else:
                um = uf(t-thetap)
        except:
            # catch any error
            um = 0
        # two states (y and y&#39;)
        y = x[0]
        dydt = x[1]
        dy2dt2 = (-2.0*zeta*taus*dydt - y + Kp*(um))/taus**2
        return [dydt,dy2dt2]

    # simulate model with x=[Km, taum, zetam, thetam]
    def simulate(self, params=None):
        if params is None:
            params = self.params

        # input arguments
        Kp = params[0]
        taus = params[1]
        zeta = params[2]
        thetap = params[3]
        
        uf = self.uf
        t = self.t
        # storage for model values
        xm = np.zeros((len(t),2))  # model
        # initial condition
        xm[0] = 0
        # loop through time steps    
        for i in range(0, len(t)-1):
            ts = [t[i],t[i+1]]
            inputs = (uf, Kp, taus, zeta, thetap)
            # integrate SOPDT model
            x = odeint(self.model, xm[i], ts, args=inputs)
            xm[i+1] = x[-1]
        y = xm[:,0]
        return y


if __name__ == &#39;__main__&#39;:
  t, y, u  = np.ones((3,100))
  t = np.cumsum(t)
  u[:5] = 0
  u[60:] = 0

  # Simulate data with second order model
  som = SOPDT(t, y, u)
  ys = som.simulate(np.array([2., 5., 0.3, 5.]))
  som.y = ys

  # Fit Second Order Model to simulated data
  result = som.fit_model(plot_result=False)
  print(result[&#34;soln&#34;])

  # Test First Order Model
  fom = FOPDT(t, ys, u)
  result = fom.fit_model(plot_result=True)
  resid = fom.y - result[&#34;y_pred&#34;]
  fom.diagnostics(resid)
  plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pydynamics.process_models.Data"><code class="flex name class">
<span>class <span class="ident">Data</span></span>
<span>(</span><span>ts, y, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Data(ts, y, u)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pydynamics.process_models.Data.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="pydynamics.process_models.Data.u"><code class="name">var <span class="ident">u</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="pydynamics.process_models.Data.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="pydynamics.process_models.FOPDT"><code class="flex name class">
<span>class <span class="ident">FOPDT</span></span>
<span>(</span><span>t, y, u, params=array([1., 1., 1.]))</span>
</code></dt>
<dd>
<div class="desc"><p>Base model class that handles the fitting and plotting for various process models</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FOPDT(ProcessModel):
  def __init__(self, t, y, u, params=np.ones((3,))):
    super(FOPDT, self).__init__(t, y, u)
    self.params = params
    self.bounds = [(-np.inf, np.inf), (0.1, np.inf), (0., np.inf)]
    
  def model(self, y, t, uf, K, tau, theta):
    try:    
      if t - theta &lt;= 0:
        um = 0
      else:
        um = uf(t - theta)
    except:
      um = 0
    dydt = (-(y) + K*(um))/tau
    return dydt

  def simulate(self, params=None, t=None, u=None):
    if params is None:
      params=self.params
    Km = params[0]
    taum = params[1]
    thetam = params[2]

    if t is None:
      t = self.t
    
    if u is None:
      u = self.u
    
    uf = interp1d(t, u)
    ym = np.zeros(len(t))

    for i in range(0, len(t)-1):
      ts=[t[i], t[i+1]]
      y1 = odeint(self.model, ym[i], ts, args=(uf, Km, taum, thetam))[-1].item()
      ym[i+1] = y1

    return ym</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pydynamics.process_models.ProcessModel" href="#pydynamics.process_models.ProcessModel">ProcessModel</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pydynamics.process_models.FOPDT.model"><code class="name flex">
<span>def <span class="ident">model</span></span>(<span>self, y, t, uf, K, tau, theta)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model(self, y, t, uf, K, tau, theta):
  try:    
    if t - theta &lt;= 0:
      um = 0
    else:
      um = uf(t - theta)
  except:
    um = 0
  dydt = (-(y) + K*(um))/tau
  return dydt</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.FOPDT.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, params=None, t=None, u=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self, params=None, t=None, u=None):
  if params is None:
    params=self.params
  Km = params[0]
  taum = params[1]
  thetam = params[2]

  if t is None:
    t = self.t
  
  if u is None:
    u = self.u
  
  uf = interp1d(t, u)
  ym = np.zeros(len(t))

  for i in range(0, len(t)-1):
    ts=[t[i], t[i+1]]
    y1 = odeint(self.model, ym[i], ts, args=(uf, Km, taum, thetam))[-1].item()
    ym[i+1] = y1

  return ym</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pydynamics.process_models.ProcessModel" href="#pydynamics.process_models.ProcessModel">ProcessModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pydynamics.process_models.ProcessModel.step" href="#pydynamics.process_models.ProcessModel.step">step</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pydynamics.process_models.Params"><code class="flex name class">
<span>class <span class="ident">Params</span></span>
<span>(</span><span>K, tau, theta, zeta)</span>
</code></dt>
<dd>
<div class="desc"><p>Params(K, tau, theta, zeta)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pydynamics.process_models.Params.K"><code class="name">var <span class="ident">K</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="pydynamics.process_models.Params.tau"><code class="name">var <span class="ident">tau</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="pydynamics.process_models.Params.theta"><code class="name">var <span class="ident">theta</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="pydynamics.process_models.Params.zeta"><code class="name">var <span class="ident">zeta</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
</dl>
</dd>
<dt id="pydynamics.process_models.ProcessModel"><code class="flex name class">
<span>class <span class="ident">ProcessModel</span></span>
<span>(</span><span>t, y, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Base model class that handles the fitting and plotting for various process models</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessModel:
  &#34;Base model class that handles the fitting and plotting for various process models&#34;

  def __init__(self, t, y, u):
    self.t = t
    self.y = y
    self.u = u
    self.uf = interp1d(t, u)

  def objective(self, params):
    ym = self.simulate(params)
    return np.sum((ym -self.y)**2)

  def fit_params(self, init_guess=None):
    if init_guess is None:
      init_guess = np.ones(self.params.shape)
    solution = minimize(self.objective, init_guess, bounds=self.bounds)
    p_opt = solution.x
    return p_opt
  
  def fit_model(self, plot_result=False):
    result = dict()
    result[&#34;soln&#34;] = self.fit_params()
    result[&#34;y_pred&#34;] = self.simulate(result[&#34;soln&#34;])
    result[&#34;mse&#34;] = self.objective(result[&#34;soln&#34;])/len(self.y)
    result[&#34;R2&#34;] = 1 - (np.var(self.y - result[&#34;y_pred&#34;])/np.var(self.y))
    self.result = result
  
    if plot_result:
      self.plot_results()

    self.result = result
    return result

  def step(self, params=None, step=1):
    &#34;&#34;&#34;
    Generate a step response plot for a FOPDT model with the given params
    &#34;&#34;&#34;
    if params is None:
      params = self.result[&#34;soln&#34;]
    taum = params[1]
    ts = np.arange(-taum, 5*taum)

    us = np.zeros((len(ts)))
    us[np.int8(taum)+1:] = step

    y = self.simulate(params, ts, us)
    plt.figure()
    plt.subplots(2,1, sharex=True)

    plt.subplot(211)
    plt.plot(ts, y)
    plt.grid()
    plt.ylabel(&#34;Output&#34;)
    plt.subplot(212)
    plt.ylabel(&#34;Input&#34;)
    plt.plot(ts, us)
    plt.grid()

  def plot_results(self):
    plt.subplots(2,1, sharex=True)
    plt.suptitle(&#34;model fit&#34;)
    
    plt.subplot(211)
    plt.plot(self.t, self.y, linewidth=2)
    plt.plot(self.t, self.result[&#34;y_pred&#34;], &#39;k--&#39;)
    plt.grid()
    plt.title(&#34;Output&#34;)
    plt.ylabel(&#34;Change in output&#34;)
    plt.legend([&#34;data&#34;, &#34;model&#34;])

    plt.subplot(212)
    plt.plot(self.t, self.u)
    plt.grid()
    plt.title(&#34;Input&#34;)
    plt.xlabel(&#34;time&#34;)
    plt.ylabel(&#34;change in input&#34;)

  def diagnostics(self, resid, plot=True):

    t = self.t
    dt = t[1]-t[0]
   
    res_norm = resid/np.linalg.norm(resid)
    u_norm = self.u/np.linalg.norm(self.u)

    resd = np.diff(resid)
    resd_norm = np.diff(resd)/np.linalg.norm(np.diff(resd))

    acf = np.correlate(res_norm, res_norm, &#39;same&#39;)
    acf[len(acf)//2] = 0
    ccf = np.correlate(u_norm, res_norm, &#39;same&#39;)

    acfd = np.correlate(resd_norm, resd_norm, &#39;same&#39;)
    acfd[len(acfd)//2] = 0
    ccfd = np.correlate(u_norm, resd_norm, &#39;same&#39;)

    self.cc_means = dict({&#34;acf&#34;: np.mean(acf**2), &#34;ccf&#34;: np.mean(ccf**2), &#34;acfd&#34;: np.mean(acfd**2), &#34;ccfd&#34;: np.mean(ccfd**2)})

    print(f&#34;{np.mean(acf**2):0.3f}, {np.mean(ccf**2):0.3f}, {np.mean(acfd**2):0.3f}, {np.mean(ccfd**2):0.3f}&#34;)


    if plot:
      plt.subplots(3, 2)
      plt.subplot(321)
      plt.plot(resid)
      plt.title(&#34;Residuals&#34;)
      plt.grid()
      
      plt.subplot(323)
      plt.title(&#34;Autocorrelation of Residuals&#34;)
      plt.plot(acf)
      plt.ylim([-1, 1])
      plt.grid()
      
      plt.subplot(325)
      plt.title(&#34;Cross-correlation: Residuals -&gt; input&#34;)
      plt.plot(ccf)

      plt.ylim([-1,1])
      plt.grid()

      plt.subplot(322)
      plt.plot(resd)
      plt.title(&#34;Residual diff&#34;)
      plt.grid()
      
      plt.subplot(324)
      plt.title(&#34;Autocorrelation of Residual diff&#34;)
      plt.plot(acfd)
      plt.ylim([-1, 1])
      plt.grid()
    
      
      plt.subplot(326)
      plt.title(&#34;Cross-correlation: Residual diff -&gt; input&#34;)
      plt.plot(ccfd)
      plt.ylim([-1,1])
      plt.grid()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pydynamics.process_models.FOPDT" href="#pydynamics.process_models.FOPDT">FOPDT</a></li>
<li><a title="pydynamics.process_models.SOPDT" href="#pydynamics.process_models.SOPDT">SOPDT</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pydynamics.process_models.ProcessModel.diagnostics"><code class="name flex">
<span>def <span class="ident">diagnostics</span></span>(<span>self, resid, plot=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagnostics(self, resid, plot=True):

  t = self.t
  dt = t[1]-t[0]
 
  res_norm = resid/np.linalg.norm(resid)
  u_norm = self.u/np.linalg.norm(self.u)

  resd = np.diff(resid)
  resd_norm = np.diff(resd)/np.linalg.norm(np.diff(resd))

  acf = np.correlate(res_norm, res_norm, &#39;same&#39;)
  acf[len(acf)//2] = 0
  ccf = np.correlate(u_norm, res_norm, &#39;same&#39;)

  acfd = np.correlate(resd_norm, resd_norm, &#39;same&#39;)
  acfd[len(acfd)//2] = 0
  ccfd = np.correlate(u_norm, resd_norm, &#39;same&#39;)

  self.cc_means = dict({&#34;acf&#34;: np.mean(acf**2), &#34;ccf&#34;: np.mean(ccf**2), &#34;acfd&#34;: np.mean(acfd**2), &#34;ccfd&#34;: np.mean(ccfd**2)})

  print(f&#34;{np.mean(acf**2):0.3f}, {np.mean(ccf**2):0.3f}, {np.mean(acfd**2):0.3f}, {np.mean(ccfd**2):0.3f}&#34;)


  if plot:
    plt.subplots(3, 2)
    plt.subplot(321)
    plt.plot(resid)
    plt.title(&#34;Residuals&#34;)
    plt.grid()
    
    plt.subplot(323)
    plt.title(&#34;Autocorrelation of Residuals&#34;)
    plt.plot(acf)
    plt.ylim([-1, 1])
    plt.grid()
    
    plt.subplot(325)
    plt.title(&#34;Cross-correlation: Residuals -&gt; input&#34;)
    plt.plot(ccf)

    plt.ylim([-1,1])
    plt.grid()

    plt.subplot(322)
    plt.plot(resd)
    plt.title(&#34;Residual diff&#34;)
    plt.grid()
    
    plt.subplot(324)
    plt.title(&#34;Autocorrelation of Residual diff&#34;)
    plt.plot(acfd)
    plt.ylim([-1, 1])
    plt.grid()
  
    
    plt.subplot(326)
    plt.title(&#34;Cross-correlation: Residual diff -&gt; input&#34;)
    plt.plot(ccfd)
    plt.ylim([-1,1])
    plt.grid()</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.fit_model"><code class="name flex">
<span>def <span class="ident">fit_model</span></span>(<span>self, plot_result=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_model(self, plot_result=False):
  result = dict()
  result[&#34;soln&#34;] = self.fit_params()
  result[&#34;y_pred&#34;] = self.simulate(result[&#34;soln&#34;])
  result[&#34;mse&#34;] = self.objective(result[&#34;soln&#34;])/len(self.y)
  result[&#34;R2&#34;] = 1 - (np.var(self.y - result[&#34;y_pred&#34;])/np.var(self.y))
  self.result = result

  if plot_result:
    self.plot_results()

  self.result = result
  return result</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.fit_params"><code class="name flex">
<span>def <span class="ident">fit_params</span></span>(<span>self, init_guess=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_params(self, init_guess=None):
  if init_guess is None:
    init_guess = np.ones(self.params.shape)
  solution = minimize(self.objective, init_guess, bounds=self.bounds)
  p_opt = solution.x
  return p_opt</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.objective"><code class="name flex">
<span>def <span class="ident">objective</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def objective(self, params):
  ym = self.simulate(params)
  return np.sum((ym -self.y)**2)</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.plot_results"><code class="name flex">
<span>def <span class="ident">plot_results</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_results(self):
  plt.subplots(2,1, sharex=True)
  plt.suptitle(&#34;model fit&#34;)
  
  plt.subplot(211)
  plt.plot(self.t, self.y, linewidth=2)
  plt.plot(self.t, self.result[&#34;y_pred&#34;], &#39;k--&#39;)
  plt.grid()
  plt.title(&#34;Output&#34;)
  plt.ylabel(&#34;Change in output&#34;)
  plt.legend([&#34;data&#34;, &#34;model&#34;])

  plt.subplot(212)
  plt.plot(self.t, self.u)
  plt.grid()
  plt.title(&#34;Input&#34;)
  plt.xlabel(&#34;time&#34;)
  plt.ylabel(&#34;change in input&#34;)</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, params=None, step=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a step response plot for a FOPDT model with the given params</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, params=None, step=1):
  &#34;&#34;&#34;
  Generate a step response plot for a FOPDT model with the given params
  &#34;&#34;&#34;
  if params is None:
    params = self.result[&#34;soln&#34;]
  taum = params[1]
  ts = np.arange(-taum, 5*taum)

  us = np.zeros((len(ts)))
  us[np.int8(taum)+1:] = step

  y = self.simulate(params, ts, us)
  plt.figure()
  plt.subplots(2,1, sharex=True)

  plt.subplot(211)
  plt.plot(ts, y)
  plt.grid()
  plt.ylabel(&#34;Output&#34;)
  plt.subplot(212)
  plt.ylabel(&#34;Input&#34;)
  plt.plot(ts, us)
  plt.grid()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pydynamics.process_models.Result"><code class="flex name class">
<span>class <span class="ident">Result</span></span>
<span>(</span><span>p_opt, p_cov, r_square, y_hat, resid)</span>
</code></dt>
<dd>
<div class="desc"><p>Result(p_opt, p_cov, r_square, y_hat, resid)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pydynamics.process_models.Result.p_cov"><code class="name">var <span class="ident">p_cov</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="pydynamics.process_models.Result.p_opt"><code class="name">var <span class="ident">p_opt</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="pydynamics.process_models.Result.r_square"><code class="name">var <span class="ident">r_square</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="pydynamics.process_models.Result.resid"><code class="name">var <span class="ident">resid</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="pydynamics.process_models.Result.y_hat"><code class="name">var <span class="ident">y_hat</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
</dl>
</dd>
<dt id="pydynamics.process_models.SOPDT"><code class="flex name class">
<span>class <span class="ident">SOPDT</span></span>
<span>(</span><span>t, y, u, params=array([1., 1., 1., 1.]))</span>
</code></dt>
<dd>
<div class="desc"><p>Base model class that handles the fitting and plotting for various process models</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SOPDT(ProcessModel):
    def __init__(self, t, y, u, params=np.ones((4,))):
        super(SOPDT, self).__init__(t, y, u)
        self.params = params
        self.bounds = [(-np.inf, np.inf), (0.01, np.inf), (0.01, np.inf), (0, np.inf)]

    def model(self, x, t, uf, Kp, taus, zeta, thetap):
    # Kp = process gain
    # taus = second order time constant
    # zeta = damping factor
    # thetap = model time delay
    # equation: ts^2 dy2/dt2 + 2 zeta taus dydt + y = Kp * u(t-thetap)

        u0 = 0
        try:
            if (t-thetap) &lt;= 0:
                um = 0
            else:
                um = uf(t-thetap)
        except:
            # catch any error
            um = 0
        # two states (y and y&#39;)
        y = x[0]
        dydt = x[1]
        dy2dt2 = (-2.0*zeta*taus*dydt - y + Kp*(um))/taus**2
        return [dydt,dy2dt2]

    # simulate model with x=[Km, taum, zetam, thetam]
    def simulate(self, params=None):
        if params is None:
            params = self.params

        # input arguments
        Kp = params[0]
        taus = params[1]
        zeta = params[2]
        thetap = params[3]
        
        uf = self.uf
        t = self.t
        # storage for model values
        xm = np.zeros((len(t),2))  # model
        # initial condition
        xm[0] = 0
        # loop through time steps    
        for i in range(0, len(t)-1):
            ts = [t[i],t[i+1]]
            inputs = (uf, Kp, taus, zeta, thetap)
            # integrate SOPDT model
            x = odeint(self.model, xm[i], ts, args=inputs)
            xm[i+1] = x[-1]
        y = xm[:,0]
        return y</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pydynamics.process_models.ProcessModel" href="#pydynamics.process_models.ProcessModel">ProcessModel</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pydynamics.process_models.SOPDT.model"><code class="name flex">
<span>def <span class="ident">model</span></span>(<span>self, x, t, uf, Kp, taus, zeta, thetap)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model(self, x, t, uf, Kp, taus, zeta, thetap):
# Kp = process gain
# taus = second order time constant
# zeta = damping factor
# thetap = model time delay
# equation: ts^2 dy2/dt2 + 2 zeta taus dydt + y = Kp * u(t-thetap)

    u0 = 0
    try:
        if (t-thetap) &lt;= 0:
            um = 0
        else:
            um = uf(t-thetap)
    except:
        # catch any error
        um = 0
    # two states (y and y&#39;)
    y = x[0]
    dydt = x[1]
    dy2dt2 = (-2.0*zeta*taus*dydt - y + Kp*(um))/taus**2
    return [dydt,dy2dt2]</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.SOPDT.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, params=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self, params=None):
    if params is None:
        params = self.params

    # input arguments
    Kp = params[0]
    taus = params[1]
    zeta = params[2]
    thetap = params[3]
    
    uf = self.uf
    t = self.t
    # storage for model values
    xm = np.zeros((len(t),2))  # model
    # initial condition
    xm[0] = 0
    # loop through time steps    
    for i in range(0, len(t)-1):
        ts = [t[i],t[i+1]]
        inputs = (uf, Kp, taus, zeta, thetap)
        # integrate SOPDT model
        x = odeint(self.model, xm[i], ts, args=inputs)
        xm[i+1] = x[-1]
    y = xm[:,0]
    return y</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pydynamics.process_models.ProcessModel" href="#pydynamics.process_models.ProcessModel">ProcessModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pydynamics.process_models.ProcessModel.step" href="#pydynamics.process_models.ProcessModel.step">step</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pydynamics" href="index.html">pydynamics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pydynamics.process_models.Data" href="#pydynamics.process_models.Data">Data</a></code></h4>
<ul class="">
<li><code><a title="pydynamics.process_models.Data.ts" href="#pydynamics.process_models.Data.ts">ts</a></code></li>
<li><code><a title="pydynamics.process_models.Data.u" href="#pydynamics.process_models.Data.u">u</a></code></li>
<li><code><a title="pydynamics.process_models.Data.y" href="#pydynamics.process_models.Data.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pydynamics.process_models.FOPDT" href="#pydynamics.process_models.FOPDT">FOPDT</a></code></h4>
<ul class="">
<li><code><a title="pydynamics.process_models.FOPDT.model" href="#pydynamics.process_models.FOPDT.model">model</a></code></li>
<li><code><a title="pydynamics.process_models.FOPDT.simulate" href="#pydynamics.process_models.FOPDT.simulate">simulate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pydynamics.process_models.Params" href="#pydynamics.process_models.Params">Params</a></code></h4>
<ul class="">
<li><code><a title="pydynamics.process_models.Params.K" href="#pydynamics.process_models.Params.K">K</a></code></li>
<li><code><a title="pydynamics.process_models.Params.tau" href="#pydynamics.process_models.Params.tau">tau</a></code></li>
<li><code><a title="pydynamics.process_models.Params.theta" href="#pydynamics.process_models.Params.theta">theta</a></code></li>
<li><code><a title="pydynamics.process_models.Params.zeta" href="#pydynamics.process_models.Params.zeta">zeta</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pydynamics.process_models.ProcessModel" href="#pydynamics.process_models.ProcessModel">ProcessModel</a></code></h4>
<ul class="two-column">
<li><code><a title="pydynamics.process_models.ProcessModel.diagnostics" href="#pydynamics.process_models.ProcessModel.diagnostics">diagnostics</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.fit_model" href="#pydynamics.process_models.ProcessModel.fit_model">fit_model</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.fit_params" href="#pydynamics.process_models.ProcessModel.fit_params">fit_params</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.objective" href="#pydynamics.process_models.ProcessModel.objective">objective</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.plot_results" href="#pydynamics.process_models.ProcessModel.plot_results">plot_results</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.step" href="#pydynamics.process_models.ProcessModel.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pydynamics.process_models.Result" href="#pydynamics.process_models.Result">Result</a></code></h4>
<ul class="">
<li><code><a title="pydynamics.process_models.Result.p_cov" href="#pydynamics.process_models.Result.p_cov">p_cov</a></code></li>
<li><code><a title="pydynamics.process_models.Result.p_opt" href="#pydynamics.process_models.Result.p_opt">p_opt</a></code></li>
<li><code><a title="pydynamics.process_models.Result.r_square" href="#pydynamics.process_models.Result.r_square">r_square</a></code></li>
<li><code><a title="pydynamics.process_models.Result.resid" href="#pydynamics.process_models.Result.resid">resid</a></code></li>
<li><code><a title="pydynamics.process_models.Result.y_hat" href="#pydynamics.process_models.Result.y_hat">y_hat</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pydynamics.process_models.SOPDT" href="#pydynamics.process_models.SOPDT">SOPDT</a></code></h4>
<ul class="">
<li><code><a title="pydynamics.process_models.SOPDT.model" href="#pydynamics.process_models.SOPDT.model">model</a></code></li>
<li><code><a title="pydynamics.process_models.SOPDT.simulate" href="#pydynamics.process_models.SOPDT.simulate">simulate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>