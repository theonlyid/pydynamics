<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pydynamics.process_models API documentation</title>
<meta name="description" content="Module containing classes for process models and fitting dynamic models to data â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pydynamics.process_models</code></h1>
</header>
<section id="section-intro">
<p>Module containing classes for process models and fitting dynamic models to data.</p>
<p>Author: Ali Zaidi</p>
<p>Version: 0.0.1</p>
<p>(C) 2025 Ali Zaidi. All rights reserved.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module containing classes for process models and fitting dynamic models to data.

Author: Ali Zaidi

Version: 0.0.1

(C) 2025 Ali Zaidi. All rights reserved.
&#34;&#34;&#34;


import numpy as np
import matplotlib.pyplot as plt
from collections import namedtuple

from scipy.integrate import odeint
from scipy.optimize import minimize
from scipy.interpolate import interp1d
from scipy import stats

import pickle

class Data:
  &#34;&#34;&#34;
  A data container for time series data.

  Attributes:
    ts (array-like): Array of time points.
    y (array-like):  Array of output data corresponding to the time points.
    u (array-like):  Array of input data corresponding to the time points.
  &#34;&#34;&#34;
  def __init__(self, ts, y, u):
    self.ts = ts
    self.y = y
    self.u = u

  def __iter__(self):
    return iter([self.ts, self.y, self.u])

  def __repr__(self):
    return f&#34;Timeseries data of length {len(self.ts)}&#34;
  
  def __str__(self):
    return f&#34;Timeseries data of length {len(self.ts)}&#34;
  

class Result:
  &#34;&#34;&#34;
  A result container for process model fitting. Contains the optimized parameters, covariance, p-values, R-squared value, model predictions, residuals, and RMSE.
  
  Attributes:
    p_opt (array-like): Optimized parameters.
    p_cov (array-like): Covariance matrix of the parameters.
    p_val (array-like): P-values of the parameters.
    r_square (float): R-squared value of the model fit.
    y_hat (array-like): Model predictions.
    resid (array-like): Residuals of the model fit.
    RMSE (float): Root Mean Squared Error of the model fit.
  &#34;&#34;&#34;
  def __init__(self, p_opt, p_cov, p_val, r_square, y_hat, resid, RMSE):
    self.p_opt = p_opt
    self.p_cov = p_cov
    self.p_val = p_val
    self.r_square = r_square
    self.y_hat = y_hat
    self.resid = resid
    self.RMSE = RMSE

  def __repr__(self):
    return f&#34;Result(p_opt={self.p_opt}, p_val={self.p_val}, r_square={self.r_square}, RMSE={self.RMSE})&#34;

  def __str__(self):
    return f&#34;Result(p_opt={self.p_opt}, p_val={self.p_val}, r_square={self.r_square}, RMSE={self.RMSE})&#34;


class ProcessModel:
  &#34;&#34;&#34;
  Base model class that handles the fitting and plotting for various process models.

  Attributes:
    Data (Data): An instance of the Data class containing time (t), output (y), and input (u) data.
    uf (interp1d): Interpolated function of the input data.
  &#34;&#34;&#34;

  def __init__(self, t, y, u):
    &#34;&#34;&#34;
    Initialize the process model with time, output, and input data.

    Args:
      t (array-like): Array of time points.
      y (array-like): Array of output data corresponding to the time points.
      u (array-like): Array of input data corresponding to the time points.
    &#34;&#34;&#34;
    self.Data = Data(t, y, u)
    self.uf = interp1d(t, u)

  def objective(self, params):
    &#34;&#34;&#34;
    Calculate the objective function value for given parameters.

    This function simulates the model with the provided parameters and computes
    the sum of squared differences between the simulated output and the actual data.

    Args:
      params (array-like): The parameters to be used for simulation.

    Returns:
      float: The sum of squared differences between the simulated output and the actual data.
    &#34;&#34;&#34;
    ym = self.simulate(params)
    return np.sum((ym - self.Data.y) ** 2)

  def fit_params(self, init_guess=None):
    &#34;&#34;&#34;
    Fit the parameters of the model using optimization.

    Args:
      init_guess (array-like, optional): Initial guess for the parameters. If None, an array of ones with the same shape as `self.params` is used.

    Returns:
      p_opt (array-like): Optimized parameters.
    &#34;&#34;&#34;
    if init_guess is None:
      init_guess = np.ones(self.params.shape)
    solution = minimize(self.objective, init_guess, bounds=self.bounds)
    p_opt = solution.x
    return p_opt

  def fit_model(self, plot_result=False, plot_diagnostics=False):
    &#34;&#34;&#34;
    Fits the model to the data, computes residuals, RMSE, R-squared value, and parameter statistics.

    Args:
      plot_result (bool, optional): If True, plots the model results. Default is False.
      plot_diagnostics (bool, optional): If True, plots diagnostic information. Default is False.

    Returns:
      Result: An object containing the fitted parameters, their covariance, p-values, R-squared value, 
      model predictions, residuals, and RMSE.
    &#34;&#34;&#34;
    p_opt = self.fit_params()  # fit the model
    y_hat = self.simulate(p_opt, self.Data.ts, self.Data.u)  # generate model predictions
    resid = self.Data.y - y_hat  # compute residuals
    rmse = np.sqrt(np.sum(resid ** 2) / len(self.Data.y))  # compute RMSE
    r_square = 1 - (np.var(self.Data.y - y_hat) / np.var(self.Data.y))  # compute R-squared value
    self.result = Result(p_opt=p_opt, p_cov=None, p_val=None, r_square=r_square, y_hat=y_hat, resid=resid, RMSE=rmse)
    p_cov = self.estimate_covariance(p_opt)
    p_val = self.pvalue(p_opt, p_cov)
    self.result = Result(p_opt=p_opt, p_cov=p_cov, p_val=p_val, r_square=r_square, y_hat=y_hat, resid=resid, RMSE=rmse)

    if plot_result:
      self.plot_results()

    if plot_diagnostics:
      self.diagnostics()
    return self.result

  def jacobian(self, params) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Compute the Jacobian matrix of the model with respect to the parameters.

    Args:
      params (array-like): The parameters for which the Jacobian is to be computed.

    Returns:
      np.ndarray: The Jacobian matrix.
    &#34;&#34;&#34;
    K, tau, theta = params
    uf = interp1d(self.Data.ts, self.Data.u, fill_value=&#34;extrapolate&#34;)
    J = np.zeros((len(self.Data.ts), 3))
    dt = self.Data.ts[1] - self.Data.ts[0]

    for i, t in enumerate(self.Data.ts):
      if t - theta &lt;= 0:
        u_delayed = 0
        u_derivative = 0
      else:
        u_delayed = uf(t - theta)
        u_derivative = (uf(t - theta + dt) - uf(t - theta)) / dt

      J[i, 0] = u_delayed / tau
      J[i, 1] = -(K * u_delayed - self.Data.y[i]) / tau ** 2
      J[i, 2] = -(K / tau) * u_derivative

    return J

  def estimate_covariance(self, params):
    &#34;&#34;&#34;
    Estimate the covariance matrix of the parameters.

    Args:
      params (array-like): The parameters for which the covariance matrix is to be estimated.

    Returns:
      np.ndarray or None: The estimated covariance matrix of the parameters. If the Jacobian is singular,
      returns None and prints an error message.
    &#34;&#34;&#34;
    res = self.result.resid
    sigma2 = np.sum(res ** 2) / (len(self.Data.ts) - len(params))
    J = self.jacobian(params)

    # Covariance matrix
    try:
      C = sigma2 * np.linalg.inv(J.T @ J)
    except np.linalg.LinAlgError:
      print(&#34;Jacobian is singular. Cannot compute confidence intervals.&#34;)
      return None

    return C

  def estimate_confidence_intervals(self, p_cov):
    &#34;&#34;&#34;
    Compute 95% confidence intervals of MLE parameters from the covariance matrix.

    Args:
      p_cov (np.ndarray): Covariance matrix of the parameters.

    Returns:
      list: List of tuples containing the lower and upper bounds of the confidence intervals for each parameter.
    &#34;&#34;&#34;
    se = np.sqrt(np.diag(p_cov))
    p_opt = self.result.p_opt

    # 95% Confidence intervals
    confidence_intervals = []

    for i in range(len(p_opt)):
      lower = p_opt[i] - 1.96 * se[i]
      upper = p_opt[i] + 1.96 * se[i]
      confidence_intervals.append((lower, upper))
    return confidence_intervals

  def pvalue(self, params, p_cov):
    &#34;&#34;&#34;
    Compute the p-values for the model parameters.

    Args:
      params (np.ndarray): Model parameters.
      p_cov (np.ndarray): Covariance matrix of the parameters.

    Returns:
      np.ndarray: Array of p-values for each parameter.
    &#34;&#34;&#34;
    se = np.sqrt(np.diag(p_cov))
    t_values = params / se
    p_values = 2 * (1 - stats.t.cdf(np.abs(t_values), len(self.Data.ts) - len(params)))
    return p_values

  @staticmethod
  def ttest(mu1, sigma1, n1, mu2, sigma2, n2) -&gt; float:
    &#34;&#34;&#34;
    Perform a two-sample t-test for the difference between two means.

    To be used to compare a parameter estimate from two different models / datasets (e.g. c_toi vs r_toi).

    Args:
      mu1 (float): Mean of the first sample.
      sigma1 (float): Standard deviation of the first sample.
      n1 (int): Number of datapoints from the first sample.
      mu2 (float): Mean of the second sample.
      sigma2 (float): Standard deviation of the second sample.
      n2 (int): Number of datapoints for the second sample.

    Returns:
      t-stat (float): The calculated t-value for the two-sample t-test.
      p-value (float): The calculated p-value for the two-sample t-test.
    &#34;&#34;&#34;
    t_value = (mu1 - mu2) / np.sqrt(sigma1 ** 2 / n1 + sigma2 ** 2 / n2)
    p_value = 2 * (1 - stats.t.cdf(np.abs(t_value), n1 + n2 - 2))

    return t_value, p_value

  def save_model(self, filename):
    &#34;&#34;&#34;
    Save the model object to a file using pickle.

    Args:
      filename (str): The name of the file to save the model object to.

    Returns:
      None
    &#34;&#34;&#34;
    with open(filename, &#39;wb&#39;) as file:
      pickle.dump(self, file)

  def plot_confidence_intervals(self):
    &#34;&#34;&#34;
    Plots the observed data, the best fit model, and the 95% confidence intervals for the model predictions.

    This method uses the time series data, the observed response, and the predicted response from the model.
    It calculates the confidence intervals based on the covariance of the parameter estimates and simulates
    the response using the lower and upper bounds of the confidence intervals. The plot includes the observed
    data points, the best fit model line, and a shaded area representing the 95% confidence interval.
    &#34;&#34;&#34;
    t = self.Data.ts
    u = self.Data.u
    y_true = self.Data.y  # Observed data
    y_pred = self.result.y_hat
    params = self.result.p_opt
    ci = self.ci_from_cov(self.result.p_cov)

    # Simulate using confidence interval bounds
    params_lower = [ci[i][0] for i in range(len(params))]
    params_upper = [ci[i][1] for i in range(len(params))]
    y_lower = self.simulate(params_lower, self.Data.ts, self.Data.u)
    y_upper = self.simulate(params_upper, self.Data.ts, self.Data.u)

    plt.figure(figsize=(8, 5))
    plt.plot(t, y_true, &#39;ko&#39;, markersize=3, label=&#34;Observed Data&#34;)
    plt.plot(t, y_pred, &#39;r-&#39;, label=&#34;Best Fit Model&#34;)
    plt.fill_between(t, y_lower, y_upper, color=&#39;red&#39;, alpha=0.3, label=&#34;95% Confidence Interval&#34;)

    plt.xlabel(&#34;Time (s)&#34;)
    plt.ylabel(&#34;Response y(t)&#34;)
    plt.title(&#34;Model Fit with Confidence Interval&#34;)
    plt.legend()
    plt.grid(True)
    plt.show()

  def step(self, params=None, step=1):
    &#34;&#34;&#34;
    Generate a step response plot for a First Order Plus Dead Time (FOPDT) model with the given parameters.

    Args:
      params (list or None): Parameters for the FOPDT model. If None, uses self.result.p_opt.
      step (int): The step input value. Default is 1.

    Returns:
      None: This function generates and displays a plot.

    The function performs the following steps:
    1. If params is None, it assigns self.result.p_opt to params.
    2. Extracts the time constant (taum) from params.
    3. Creates a time array (ts) ranging from -taum to 5 * taum.
    4. Initializes an input array (us) with zeros and sets the step input after taum.
    5. Simulates the FOPDT model response using the given parameters, time array, and input array.
    6. Plots the output response and input signal on two subplots.
    &#34;&#34;&#34;
    if params is None:
      params = self.result.p_opt
    taum = params[1]
    ts = np.arange(-taum, 5 * taum)

    us = np.zeros((len(ts)))
    us[np.int8(taum) + 1:] = step

    y = self.simulate(params, ts, us)
    plt.figure()
    plt.subplots(2, 1, sharex=True)

    plt.subplot(211)
    plt.plot(ts, y)
    plt.grid()
    plt.ylabel(&#34;Output&#34;)
    plt.subplot(212)
    plt.ylabel(&#34;Input&#34;)
    plt.plot(ts, us)
    plt.grid()

  def plot_results(self):
    &#34;&#34;&#34;
    Plots the results of the model fit, including the observed data, model predictions, 
    and prediction intervals.

    This method generates a plot with two y-axes:
    - The left y-axis shows the change in output with observed data points, model predictions, 
      and prediction intervals.
    - The right y-axis shows the change in input over time.

    The plot includes:
    - A title displaying the R-squared value and RMSE of the model fit.
    - Observed data points as blue dots.
    - Model predictions as a black line.
    - 95% prediction intervals as a shaded red area.
    - Standard error of the mean (SEM) intervals as a shaded red area with higher opacity.
    - Change in input as a gray line (right axis).

    The method also adjusts the layout to ensure the right y-label is not clipped.
    &#34;&#34;&#34;
    # gather variables
    ts, ys, us = self.Data
    res = self.result

    # calculate prediction intervals
    sem = np.sqrt(np.sum((res.resid) ** 2) / (len(ys) - 3))
    pi95 = 1.96 * sem

    fig, ax1 = plt.subplots(figsize=(8, 6))
    plt.title(f&#34;Model fit: Rsq = {res.r_square:0.3f}, RMSE = {res.RMSE:0.3f}&#34;)

    color = &#39;tab:blue&#39;
    ax1.set_xlabel(&#39;time&#39;)
    ax1.set_ylabel(&#39;Change in output&#39;, color=color)
    ax1.fill_between(ts, res.y_hat - pi95, res.y_hat + pi95, color=&#39;r&#39;, alpha=0.15, label=&#39;95% PI&#39;)
    ax1.fill_between(ts, res.y_hat - sem, res.y_hat + sem, color=&#39;r&#39;, alpha=0.2, label=&#39;SE PI&#39;)
    ax1.plot(ts, ys, &#39;b.&#39;, label=&#39;observations&#39;, alpha=0.6)
    ax1.plot(ts, res.y_hat, &#39;k&#39;, linewidth=1.5, label=&#39;model&#39;)
    ax1.tick_params(axis=&#39;y&#39;, labelcolor=color)
    ax1.legend(loc=&#39;upper left&#39;)
    ax1.grid()

    ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
    color = &#39;tab:gray&#39;
    ax2.set_ylabel(&#39;Change in input&#39;, color=color)  # we already handled the x-label with ax1
    ax2.plot(ts, us, color=color)
    ax2.tick_params(axis=&#39;y&#39;, labelcolor=color)
    ax2.set_ylim([min(us) - (0.1 * max(us)), 10 * max(us)])

    fig.tight_layout()  # otherwise the right y-label is slightly clipped
    plt.show()

  def diagnostics(self, plot=True):
    &#34;&#34;&#34;
    Perform diagnostics on the model&#39;s residuals and input data.

    This method calculates and prints the mean squared values of the 
    autocorrelation and cross-correlation functions of the residuals 
    and their differences. Optionally, it plots these diagnostics.

    Args:
      plot (bool, optional): If True, plots the diagnostics. Default is True.

    Attributes:
      cc_means (dict): A dictionary containing the mean squared values of the 
      autocorrelation and cross-correlation functions:
        - &#34;acf&#34;: Autocorrelation of residuals
        - &#34;ccf&#34;: Cross-correlation of residuals with input
        - &#34;acfd&#34;: Autocorrelation of residual differences
        - &#34;ccfd&#34;: Cross-correlation of residual differences with input

    Prints:
      Mean absolute values of the autocorrelation and cross-correlation 
      functions.

    Plots:
      If plot is True, generates the following plots:
        - Residuals
        - Autocorrelation of residuals
        - Cross-correlation of residuals with input
        - Residual differences
        - Autocorrelation of residual differences
        - Cross-correlation of residual differences with input
    &#34;&#34;&#34;
    t = self.Data.ts
    dt = t[1] - t[0]
    resid = self.result.resid
    res_norm = resid / np.linalg.norm(resid)
    u_norm = self.Data.u / np.linalg.norm(self.Data.u)

    resd = np.diff(resid)
    resd_norm = np.diff(resd) / np.linalg.norm(np.diff(resd))

    acf = np.correlate(res_norm, res_norm, &#39;same&#39;)
    acf[len(acf) // 2] = 0
    ccf = np.correlate(u_norm, res_norm, &#39;same&#39;)

    acfd = np.correlate(resd_norm, resd_norm, &#39;same&#39;)
    acfd[len(acfd) // 2] = 0
    ccfd = np.correlate(u_norm, resd_norm, &#39;same&#39;)

    self.cc_means = dict({&#34;acf&#34;: np.mean(acf ** 2), &#34;ccf&#34;: np.mean(ccf ** 2), &#34;acfd&#34;: np.mean(acfd ** 2), &#34;ccfd&#34;: np.mean(ccfd ** 2)})

    print(f&#34;Residual ACF:{np.mean(acf ** 2):0.3f}, CCF:{np.mean(ccf ** 2):0.3f}, ACFD:{np.mean(acfd ** 2):0.3f}, CCFD:{np.mean(ccfd ** 2):0.3f}&#34;)

    if plot:
      plt.subplots(3, 2)
      plt.subplot(321)
      plt.plot(resid)
      plt.title(&#34;Residuals&#34;)
      plt.grid()

      plt.subplot(323)
      plt.title(&#34;Autocorrelation of Residuals&#34;)
      plt.plot(acf)
      plt.ylim([-1, 1])
      plt.grid()

      plt.subplot(325)
      plt.title(&#34;Cross-correlation: Residuals -&gt; input&#34;)
      plt.plot(ccf)

      plt.ylim([-1, 1])
      plt.grid()

      plt.subplot(322)
      plt.plot(resd)
      plt.title(&#34;Residual diff&#34;)
      plt.grid()

      plt.subplot(324)
      plt.title(&#34;Autocorrelation of Residual diff&#34;)
      plt.plot(acfd)
      plt.ylim([-1, 1])
      plt.grid()

      plt.subplot(326)
      plt.title(&#34;Cross-correlation: Residual diff -&gt; input&#34;)
      plt.plot(ccfd)
      plt.ylim([-1, 1])
      plt.grid()


class FOPDT(ProcessModel):
  &#34;&#34;&#34;
  First-Order Plus Dead Time (FOPDT) process model.
  This class represents a first-order plus dead time (FOPDT) process model, which is commonly used in process control to describe the dynamic behavior of a system.

  Attributes:
    params (numpy.ndarray): An array containing the default parameters of the system (K, tau, theta).
    bounds (list): A list of tuples specifying the bounds for the parameters (K, tau, theta).
    tmin (float):  The minimum time value in the time vector `t`.

  &#34;&#34;&#34;
  def __init__(self, t, y, u, params=np.ones((3,))):
    &#34;&#34;&#34;
    Initialize the FOPDT model with time, output, and input data.
    
    Args:
      t (array-like): Array of time points.
      y (array-like): Array of output data corresponding to the time points.
      u (array-like): Array of input data corresponding to the time points.
      params (array-like, optional): Default parameters for the FOPDT model. Default is np.ones((3,)).
    &#34;&#34;&#34;
    super(FOPDT, self).__init__(t, y, u)
    self.params = params
    self.bounds = [(-np.inf, np.inf), (0.1, np.inf), (0., np.inf)]
    self.tmin = min(t)

  def model(self, y, t, uf, K, tau, theta):
    &#34;&#34;&#34;
    Computes the derivative of the system state `y` at time `t` for a given input function `uf`.

    Args:
      y (float): The current state of the system.
      t (float): The current time.
      uf (function): A function representing the input to the system, which takes time `t` as an argument.
      K (float): The system gain.
      tau (float): The system time constant.
      theta (float): The time delay of the system.

    Returns:
      dy/dt (float): The derivative of the system state `y` at time `t`.
    &#34;&#34;&#34;
    try:
      if t - theta &lt;= self.tmin:
        um = 0
      else:
        um = uf(t - theta)
    except:
      um = 0
    dydt = (-(y) + K * (um)) / tau
    return dydt

  def simulate(self, params=None, t=None, u=None):
    &#34;&#34;&#34;
    Simulate the dynamic system using the provided parameters, time vector, and input signal.

    Args:
      params (tuple, optional): A tuple containing the system parameters (K, tau, theta). If not provided, the default parameters of the object are used.
      t (array-like, optional): The time vector for the simulation. If not provided, the default time vector of the object is used.
      u (array-like, optional): The input signal for the simulation. If not provided, the default input signal of the object is used.

    Returns:
      ym (numpy.ndarray): The simulated output of the dynamic system over the given time vector.
    &#34;&#34;&#34;
    if params is None:
      params = self.params
    K, tau, theta = params

    if t is None:
      t = self.Data.ts

    if u is None:
      u = self.Data.u

    uf = interp1d(t, u)
    ym = np.zeros(len(t))

    for i in range(len(t) - 1):
      ts = [t[i], t[i + 1]]
      y1 = odeint(self.model, ym[i], ts, args=(uf, K, tau, theta))[-1].item()
      ym[i + 1] = y1

    return ym


class SOPDT(ProcessModel):
  def __init__(self, t, y, u, params=np.ones((4,))):
    super(SOPDT, self).__init__(t, y, u)
    self.params = params
    self.bounds = [(-np.inf, np.inf), (0.01, np.inf), (0.01, np.inf), (0, np.inf)]

  def model(self, x, t, uf, Kp, taus, zeta, thetap):
    
    # Kp = process gain
    # taus = second order time constant
    # zeta = damping factor
    # thetap = model time delay
    # equation: ts^2 dy2/dt2 + 2 zeta taus dydt + y = Kp * u(t-thetap)

    u0 = 0
    try:
      if (t - thetap) &lt;= 0:
        um = 0
      else:
        um = uf(t - thetap)
    except:
      # catch any error
      um = 0
    # two states (y and y&#39;)
    y = x[0]
    dydt = x[1]
    dy2dt2 = (-2.0 * zeta * taus * dydt - y + Kp * (um)) / taus ** 2
    return [dydt, dy2dt2]

  # simulate model with x=[Km, taum, zetam, thetam]
  def simulate(self, params=None):
    &#34;&#34;&#34;
    Simulate the system using the given parameters.

    Parameters:
    params (tuple, optional): A tuple containing the parameters (Kp, taus, zeta, thetap) 
                  for the simulation. If None, self.params will be used.
    
    Returns:
    numpy.ndarray: The simulated output values over time.
    &#34;&#34;&#34;
    if params is None:
      params = self.params
    Kp, taus, zeta, thetap = params

    uf = self.uf
    t = self.Data.t
    # storage for model values
    xm = np.zeros((len(t), 2))  # model
    # initial condition
    xm[0] = 0
    # loop through time steps
    for i in range(len(t) - 1):
      ts = [t[i], t[i + 1]]
      inputs = (uf, Kp, taus, zeta, thetap)
      # integrate SOPDT model
      x = odeint(self.model, xm[i], ts, args=inputs)
      xm[i + 1] = x[-1]
    y = xm[:, 0]
    return y


if __name__ == &#39;__main__&#39;:
  
  # Generate sample data
  t, y, u  = np.ones((3,100))
  t = np.cumsum(t)
  u[:5] = 0
  u[60:] = 0

  # Test First Order Model
  fom = FOPDT(t, y, u) # initialize the model
  ys = fom.simulate(np.array([2., 5., 5.])) # simulate the model with given parameters
  noise = np.random.normal(0, 0.5, len(ys)) # add noise to the output
  yn = ys + noise
  fom = FOPDT(t, yn, u) # initialize the model with noisy data
  result = fom.fit_model(plot_result=True) # fit the model to the data and plot the results
  print(f&#34;Params: K: {result.p_opt[0]:0.3f}, tau: {result.p_opt[1]:0.3f}, theta: {result.p_opt[2]:0.3f}&#34;)
  print(f&#34;P-values: K: {result.p_val[0]:0.3f}, tau: {result.p_val[1]:0.3f}, theta: {result.p_val[2]:0.3f}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pydynamics.process_models.Data"><code class="flex name class">
<span>class <span class="ident">Data</span></span>
<span>(</span><span>ts, y, u)</span>
</code></dt>
<dd>
<div class="desc"><p>A data container for time series data.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Array of time points.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Array of output data corresponding to the time points.</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Array of input data corresponding to the time points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Data:
  &#34;&#34;&#34;
  A data container for time series data.

  Attributes:
    ts (array-like): Array of time points.
    y (array-like):  Array of output data corresponding to the time points.
    u (array-like):  Array of input data corresponding to the time points.
  &#34;&#34;&#34;
  def __init__(self, ts, y, u):
    self.ts = ts
    self.y = y
    self.u = u

  def __iter__(self):
    return iter([self.ts, self.y, self.u])

  def __repr__(self):
    return f&#34;Timeseries data of length {len(self.ts)}&#34;
  
  def __str__(self):
    return f&#34;Timeseries data of length {len(self.ts)}&#34;</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.FOPDT"><code class="flex name class">
<span>class <span class="ident">FOPDT</span></span>
<span>(</span><span>t, y, u, params=array([1., 1., 1.]))</span>
</code></dt>
<dd>
<div class="desc"><p>First-Order Plus Dead Time (FOPDT) process model.
This class represents a first-order plus dead time (FOPDT) process model, which is commonly used in process control to describe the dynamic behavior of a system.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>An array containing the default parameters of the system (K, tau, theta).</dd>
<dt><strong><code>bounds</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of tuples specifying the bounds for the parameters (K, tau, theta).</dd>
<dt><strong><code>tmin</code></strong> :&ensp;<code>float</code></dt>
<dd>The minimum time value in the time vector <code>t</code>.</dd>
</dl>
<p>Initialize the FOPDT model with time, output, and input data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Array of time points.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Array of output data corresponding to the time points.</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Array of input data corresponding to the time points.</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>Default parameters for the FOPDT model. Default is np.ones((3,)).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FOPDT(ProcessModel):
  &#34;&#34;&#34;
  First-Order Plus Dead Time (FOPDT) process model.
  This class represents a first-order plus dead time (FOPDT) process model, which is commonly used in process control to describe the dynamic behavior of a system.

  Attributes:
    params (numpy.ndarray): An array containing the default parameters of the system (K, tau, theta).
    bounds (list): A list of tuples specifying the bounds for the parameters (K, tau, theta).
    tmin (float):  The minimum time value in the time vector `t`.

  &#34;&#34;&#34;
  def __init__(self, t, y, u, params=np.ones((3,))):
    &#34;&#34;&#34;
    Initialize the FOPDT model with time, output, and input data.
    
    Args:
      t (array-like): Array of time points.
      y (array-like): Array of output data corresponding to the time points.
      u (array-like): Array of input data corresponding to the time points.
      params (array-like, optional): Default parameters for the FOPDT model. Default is np.ones((3,)).
    &#34;&#34;&#34;
    super(FOPDT, self).__init__(t, y, u)
    self.params = params
    self.bounds = [(-np.inf, np.inf), (0.1, np.inf), (0., np.inf)]
    self.tmin = min(t)

  def model(self, y, t, uf, K, tau, theta):
    &#34;&#34;&#34;
    Computes the derivative of the system state `y` at time `t` for a given input function `uf`.

    Args:
      y (float): The current state of the system.
      t (float): The current time.
      uf (function): A function representing the input to the system, which takes time `t` as an argument.
      K (float): The system gain.
      tau (float): The system time constant.
      theta (float): The time delay of the system.

    Returns:
      dy/dt (float): The derivative of the system state `y` at time `t`.
    &#34;&#34;&#34;
    try:
      if t - theta &lt;= self.tmin:
        um = 0
      else:
        um = uf(t - theta)
    except:
      um = 0
    dydt = (-(y) + K * (um)) / tau
    return dydt

  def simulate(self, params=None, t=None, u=None):
    &#34;&#34;&#34;
    Simulate the dynamic system using the provided parameters, time vector, and input signal.

    Args:
      params (tuple, optional): A tuple containing the system parameters (K, tau, theta). If not provided, the default parameters of the object are used.
      t (array-like, optional): The time vector for the simulation. If not provided, the default time vector of the object is used.
      u (array-like, optional): The input signal for the simulation. If not provided, the default input signal of the object is used.

    Returns:
      ym (numpy.ndarray): The simulated output of the dynamic system over the given time vector.
    &#34;&#34;&#34;
    if params is None:
      params = self.params
    K, tau, theta = params

    if t is None:
      t = self.Data.ts

    if u is None:
      u = self.Data.u

    uf = interp1d(t, u)
    ym = np.zeros(len(t))

    for i in range(len(t) - 1):
      ts = [t[i], t[i + 1]]
      y1 = odeint(self.model, ym[i], ts, args=(uf, K, tau, theta))[-1].item()
      ym[i + 1] = y1

    return ym</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pydynamics.process_models.ProcessModel" href="#pydynamics.process_models.ProcessModel">ProcessModel</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pydynamics.process_models.FOPDT.model"><code class="name flex">
<span>def <span class="ident">model</span></span>(<span>self, y, t, uf, K, tau, theta)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the derivative of the system state <code>y</code> at time <code>t</code> for a given input function <code>uf</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>The current state of the system.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>The current time.</dd>
<dt><strong><code>uf</code></strong> :&ensp;<code>function</code></dt>
<dd>A function representing the input to the system, which takes time <code>t</code> as an argument.</dd>
<dt><strong><code>K</code></strong> :&ensp;<code>float</code></dt>
<dd>The system gain.</dd>
<dt><strong><code>tau</code></strong> :&ensp;<code>float</code></dt>
<dd>The system time constant.</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>The time delay of the system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dy/dt (float): The derivative of the system state <code>y</code> at time <code>t</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model(self, y, t, uf, K, tau, theta):
  &#34;&#34;&#34;
  Computes the derivative of the system state `y` at time `t` for a given input function `uf`.

  Args:
    y (float): The current state of the system.
    t (float): The current time.
    uf (function): A function representing the input to the system, which takes time `t` as an argument.
    K (float): The system gain.
    tau (float): The system time constant.
    theta (float): The time delay of the system.

  Returns:
    dy/dt (float): The derivative of the system state `y` at time `t`.
  &#34;&#34;&#34;
  try:
    if t - theta &lt;= self.tmin:
      um = 0
    else:
      um = uf(t - theta)
  except:
    um = 0
  dydt = (-(y) + K * (um)) / tau
  return dydt</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.FOPDT.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, params=None, t=None, u=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate the dynamic system using the provided parameters, time vector, and input signal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>A tuple containing the system parameters (K, tau, theta). If not provided, the default parameters of the object are used.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>The time vector for the simulation. If not provided, the default time vector of the object is used.</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>The input signal for the simulation. If not provided, the default input signal of the object is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ym (numpy.ndarray): The simulated output of the dynamic system over the given time vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self, params=None, t=None, u=None):
  &#34;&#34;&#34;
  Simulate the dynamic system using the provided parameters, time vector, and input signal.

  Args:
    params (tuple, optional): A tuple containing the system parameters (K, tau, theta). If not provided, the default parameters of the object are used.
    t (array-like, optional): The time vector for the simulation. If not provided, the default time vector of the object is used.
    u (array-like, optional): The input signal for the simulation. If not provided, the default input signal of the object is used.

  Returns:
    ym (numpy.ndarray): The simulated output of the dynamic system over the given time vector.
  &#34;&#34;&#34;
  if params is None:
    params = self.params
  K, tau, theta = params

  if t is None:
    t = self.Data.ts

  if u is None:
    u = self.Data.u

  uf = interp1d(t, u)
  ym = np.zeros(len(t))

  for i in range(len(t) - 1):
    ts = [t[i], t[i + 1]]
    y1 = odeint(self.model, ym[i], ts, args=(uf, K, tau, theta))[-1].item()
    ym[i + 1] = y1

  return ym</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pydynamics.process_models.ProcessModel" href="#pydynamics.process_models.ProcessModel">ProcessModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pydynamics.process_models.ProcessModel.diagnostics" href="#pydynamics.process_models.ProcessModel.diagnostics">diagnostics</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.estimate_confidence_intervals" href="#pydynamics.process_models.ProcessModel.estimate_confidence_intervals">estimate_confidence_intervals</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.estimate_covariance" href="#pydynamics.process_models.ProcessModel.estimate_covariance">estimate_covariance</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.fit_model" href="#pydynamics.process_models.ProcessModel.fit_model">fit_model</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.fit_params" href="#pydynamics.process_models.ProcessModel.fit_params">fit_params</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.jacobian" href="#pydynamics.process_models.ProcessModel.jacobian">jacobian</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.objective" href="#pydynamics.process_models.ProcessModel.objective">objective</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.plot_confidence_intervals" href="#pydynamics.process_models.ProcessModel.plot_confidence_intervals">plot_confidence_intervals</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.plot_results" href="#pydynamics.process_models.ProcessModel.plot_results">plot_results</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.pvalue" href="#pydynamics.process_models.ProcessModel.pvalue">pvalue</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.save_model" href="#pydynamics.process_models.ProcessModel.save_model">save_model</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.step" href="#pydynamics.process_models.ProcessModel.step">step</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.ttest" href="#pydynamics.process_models.ProcessModel.ttest">ttest</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pydynamics.process_models.ProcessModel"><code class="flex name class">
<span>class <span class="ident">ProcessModel</span></span>
<span>(</span><span>t, y, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Base model class that handles the fitting and plotting for various process models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>Data</code></strong> :&ensp;<code><a title="pydynamics.process_models.Data" href="#pydynamics.process_models.Data">Data</a></code></dt>
<dd>An instance of the Data class containing time (t), output (y), and input (u) data.</dd>
<dt><strong><code>uf</code></strong> :&ensp;<code>interp1d</code></dt>
<dd>Interpolated function of the input data.</dd>
</dl>
<p>Initialize the process model with time, output, and input data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Array of time points.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Array of output data corresponding to the time points.</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Array of input data corresponding to the time points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessModel:
  &#34;&#34;&#34;
  Base model class that handles the fitting and plotting for various process models.

  Attributes:
    Data (Data): An instance of the Data class containing time (t), output (y), and input (u) data.
    uf (interp1d): Interpolated function of the input data.
  &#34;&#34;&#34;

  def __init__(self, t, y, u):
    &#34;&#34;&#34;
    Initialize the process model with time, output, and input data.

    Args:
      t (array-like): Array of time points.
      y (array-like): Array of output data corresponding to the time points.
      u (array-like): Array of input data corresponding to the time points.
    &#34;&#34;&#34;
    self.Data = Data(t, y, u)
    self.uf = interp1d(t, u)

  def objective(self, params):
    &#34;&#34;&#34;
    Calculate the objective function value for given parameters.

    This function simulates the model with the provided parameters and computes
    the sum of squared differences between the simulated output and the actual data.

    Args:
      params (array-like): The parameters to be used for simulation.

    Returns:
      float: The sum of squared differences between the simulated output and the actual data.
    &#34;&#34;&#34;
    ym = self.simulate(params)
    return np.sum((ym - self.Data.y) ** 2)

  def fit_params(self, init_guess=None):
    &#34;&#34;&#34;
    Fit the parameters of the model using optimization.

    Args:
      init_guess (array-like, optional): Initial guess for the parameters. If None, an array of ones with the same shape as `self.params` is used.

    Returns:
      p_opt (array-like): Optimized parameters.
    &#34;&#34;&#34;
    if init_guess is None:
      init_guess = np.ones(self.params.shape)
    solution = minimize(self.objective, init_guess, bounds=self.bounds)
    p_opt = solution.x
    return p_opt

  def fit_model(self, plot_result=False, plot_diagnostics=False):
    &#34;&#34;&#34;
    Fits the model to the data, computes residuals, RMSE, R-squared value, and parameter statistics.

    Args:
      plot_result (bool, optional): If True, plots the model results. Default is False.
      plot_diagnostics (bool, optional): If True, plots diagnostic information. Default is False.

    Returns:
      Result: An object containing the fitted parameters, their covariance, p-values, R-squared value, 
      model predictions, residuals, and RMSE.
    &#34;&#34;&#34;
    p_opt = self.fit_params()  # fit the model
    y_hat = self.simulate(p_opt, self.Data.ts, self.Data.u)  # generate model predictions
    resid = self.Data.y - y_hat  # compute residuals
    rmse = np.sqrt(np.sum(resid ** 2) / len(self.Data.y))  # compute RMSE
    r_square = 1 - (np.var(self.Data.y - y_hat) / np.var(self.Data.y))  # compute R-squared value
    self.result = Result(p_opt=p_opt, p_cov=None, p_val=None, r_square=r_square, y_hat=y_hat, resid=resid, RMSE=rmse)
    p_cov = self.estimate_covariance(p_opt)
    p_val = self.pvalue(p_opt, p_cov)
    self.result = Result(p_opt=p_opt, p_cov=p_cov, p_val=p_val, r_square=r_square, y_hat=y_hat, resid=resid, RMSE=rmse)

    if plot_result:
      self.plot_results()

    if plot_diagnostics:
      self.diagnostics()
    return self.result

  def jacobian(self, params) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Compute the Jacobian matrix of the model with respect to the parameters.

    Args:
      params (array-like): The parameters for which the Jacobian is to be computed.

    Returns:
      np.ndarray: The Jacobian matrix.
    &#34;&#34;&#34;
    K, tau, theta = params
    uf = interp1d(self.Data.ts, self.Data.u, fill_value=&#34;extrapolate&#34;)
    J = np.zeros((len(self.Data.ts), 3))
    dt = self.Data.ts[1] - self.Data.ts[0]

    for i, t in enumerate(self.Data.ts):
      if t - theta &lt;= 0:
        u_delayed = 0
        u_derivative = 0
      else:
        u_delayed = uf(t - theta)
        u_derivative = (uf(t - theta + dt) - uf(t - theta)) / dt

      J[i, 0] = u_delayed / tau
      J[i, 1] = -(K * u_delayed - self.Data.y[i]) / tau ** 2
      J[i, 2] = -(K / tau) * u_derivative

    return J

  def estimate_covariance(self, params):
    &#34;&#34;&#34;
    Estimate the covariance matrix of the parameters.

    Args:
      params (array-like): The parameters for which the covariance matrix is to be estimated.

    Returns:
      np.ndarray or None: The estimated covariance matrix of the parameters. If the Jacobian is singular,
      returns None and prints an error message.
    &#34;&#34;&#34;
    res = self.result.resid
    sigma2 = np.sum(res ** 2) / (len(self.Data.ts) - len(params))
    J = self.jacobian(params)

    # Covariance matrix
    try:
      C = sigma2 * np.linalg.inv(J.T @ J)
    except np.linalg.LinAlgError:
      print(&#34;Jacobian is singular. Cannot compute confidence intervals.&#34;)
      return None

    return C

  def estimate_confidence_intervals(self, p_cov):
    &#34;&#34;&#34;
    Compute 95% confidence intervals of MLE parameters from the covariance matrix.

    Args:
      p_cov (np.ndarray): Covariance matrix of the parameters.

    Returns:
      list: List of tuples containing the lower and upper bounds of the confidence intervals for each parameter.
    &#34;&#34;&#34;
    se = np.sqrt(np.diag(p_cov))
    p_opt = self.result.p_opt

    # 95% Confidence intervals
    confidence_intervals = []

    for i in range(len(p_opt)):
      lower = p_opt[i] - 1.96 * se[i]
      upper = p_opt[i] + 1.96 * se[i]
      confidence_intervals.append((lower, upper))
    return confidence_intervals

  def pvalue(self, params, p_cov):
    &#34;&#34;&#34;
    Compute the p-values for the model parameters.

    Args:
      params (np.ndarray): Model parameters.
      p_cov (np.ndarray): Covariance matrix of the parameters.

    Returns:
      np.ndarray: Array of p-values for each parameter.
    &#34;&#34;&#34;
    se = np.sqrt(np.diag(p_cov))
    t_values = params / se
    p_values = 2 * (1 - stats.t.cdf(np.abs(t_values), len(self.Data.ts) - len(params)))
    return p_values

  @staticmethod
  def ttest(mu1, sigma1, n1, mu2, sigma2, n2) -&gt; float:
    &#34;&#34;&#34;
    Perform a two-sample t-test for the difference between two means.

    To be used to compare a parameter estimate from two different models / datasets (e.g. c_toi vs r_toi).

    Args:
      mu1 (float): Mean of the first sample.
      sigma1 (float): Standard deviation of the first sample.
      n1 (int): Number of datapoints from the first sample.
      mu2 (float): Mean of the second sample.
      sigma2 (float): Standard deviation of the second sample.
      n2 (int): Number of datapoints for the second sample.

    Returns:
      t-stat (float): The calculated t-value for the two-sample t-test.
      p-value (float): The calculated p-value for the two-sample t-test.
    &#34;&#34;&#34;
    t_value = (mu1 - mu2) / np.sqrt(sigma1 ** 2 / n1 + sigma2 ** 2 / n2)
    p_value = 2 * (1 - stats.t.cdf(np.abs(t_value), n1 + n2 - 2))

    return t_value, p_value

  def save_model(self, filename):
    &#34;&#34;&#34;
    Save the model object to a file using pickle.

    Args:
      filename (str): The name of the file to save the model object to.

    Returns:
      None
    &#34;&#34;&#34;
    with open(filename, &#39;wb&#39;) as file:
      pickle.dump(self, file)

  def plot_confidence_intervals(self):
    &#34;&#34;&#34;
    Plots the observed data, the best fit model, and the 95% confidence intervals for the model predictions.

    This method uses the time series data, the observed response, and the predicted response from the model.
    It calculates the confidence intervals based on the covariance of the parameter estimates and simulates
    the response using the lower and upper bounds of the confidence intervals. The plot includes the observed
    data points, the best fit model line, and a shaded area representing the 95% confidence interval.
    &#34;&#34;&#34;
    t = self.Data.ts
    u = self.Data.u
    y_true = self.Data.y  # Observed data
    y_pred = self.result.y_hat
    params = self.result.p_opt
    ci = self.ci_from_cov(self.result.p_cov)

    # Simulate using confidence interval bounds
    params_lower = [ci[i][0] for i in range(len(params))]
    params_upper = [ci[i][1] for i in range(len(params))]
    y_lower = self.simulate(params_lower, self.Data.ts, self.Data.u)
    y_upper = self.simulate(params_upper, self.Data.ts, self.Data.u)

    plt.figure(figsize=(8, 5))
    plt.plot(t, y_true, &#39;ko&#39;, markersize=3, label=&#34;Observed Data&#34;)
    plt.plot(t, y_pred, &#39;r-&#39;, label=&#34;Best Fit Model&#34;)
    plt.fill_between(t, y_lower, y_upper, color=&#39;red&#39;, alpha=0.3, label=&#34;95% Confidence Interval&#34;)

    plt.xlabel(&#34;Time (s)&#34;)
    plt.ylabel(&#34;Response y(t)&#34;)
    plt.title(&#34;Model Fit with Confidence Interval&#34;)
    plt.legend()
    plt.grid(True)
    plt.show()

  def step(self, params=None, step=1):
    &#34;&#34;&#34;
    Generate a step response plot for a First Order Plus Dead Time (FOPDT) model with the given parameters.

    Args:
      params (list or None): Parameters for the FOPDT model. If None, uses self.result.p_opt.
      step (int): The step input value. Default is 1.

    Returns:
      None: This function generates and displays a plot.

    The function performs the following steps:
    1. If params is None, it assigns self.result.p_opt to params.
    2. Extracts the time constant (taum) from params.
    3. Creates a time array (ts) ranging from -taum to 5 * taum.
    4. Initializes an input array (us) with zeros and sets the step input after taum.
    5. Simulates the FOPDT model response using the given parameters, time array, and input array.
    6. Plots the output response and input signal on two subplots.
    &#34;&#34;&#34;
    if params is None:
      params = self.result.p_opt
    taum = params[1]
    ts = np.arange(-taum, 5 * taum)

    us = np.zeros((len(ts)))
    us[np.int8(taum) + 1:] = step

    y = self.simulate(params, ts, us)
    plt.figure()
    plt.subplots(2, 1, sharex=True)

    plt.subplot(211)
    plt.plot(ts, y)
    plt.grid()
    plt.ylabel(&#34;Output&#34;)
    plt.subplot(212)
    plt.ylabel(&#34;Input&#34;)
    plt.plot(ts, us)
    plt.grid()

  def plot_results(self):
    &#34;&#34;&#34;
    Plots the results of the model fit, including the observed data, model predictions, 
    and prediction intervals.

    This method generates a plot with two y-axes:
    - The left y-axis shows the change in output with observed data points, model predictions, 
      and prediction intervals.
    - The right y-axis shows the change in input over time.

    The plot includes:
    - A title displaying the R-squared value and RMSE of the model fit.
    - Observed data points as blue dots.
    - Model predictions as a black line.
    - 95% prediction intervals as a shaded red area.
    - Standard error of the mean (SEM) intervals as a shaded red area with higher opacity.
    - Change in input as a gray line (right axis).

    The method also adjusts the layout to ensure the right y-label is not clipped.
    &#34;&#34;&#34;
    # gather variables
    ts, ys, us = self.Data
    res = self.result

    # calculate prediction intervals
    sem = np.sqrt(np.sum((res.resid) ** 2) / (len(ys) - 3))
    pi95 = 1.96 * sem

    fig, ax1 = plt.subplots(figsize=(8, 6))
    plt.title(f&#34;Model fit: Rsq = {res.r_square:0.3f}, RMSE = {res.RMSE:0.3f}&#34;)

    color = &#39;tab:blue&#39;
    ax1.set_xlabel(&#39;time&#39;)
    ax1.set_ylabel(&#39;Change in output&#39;, color=color)
    ax1.fill_between(ts, res.y_hat - pi95, res.y_hat + pi95, color=&#39;r&#39;, alpha=0.15, label=&#39;95% PI&#39;)
    ax1.fill_between(ts, res.y_hat - sem, res.y_hat + sem, color=&#39;r&#39;, alpha=0.2, label=&#39;SE PI&#39;)
    ax1.plot(ts, ys, &#39;b.&#39;, label=&#39;observations&#39;, alpha=0.6)
    ax1.plot(ts, res.y_hat, &#39;k&#39;, linewidth=1.5, label=&#39;model&#39;)
    ax1.tick_params(axis=&#39;y&#39;, labelcolor=color)
    ax1.legend(loc=&#39;upper left&#39;)
    ax1.grid()

    ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
    color = &#39;tab:gray&#39;
    ax2.set_ylabel(&#39;Change in input&#39;, color=color)  # we already handled the x-label with ax1
    ax2.plot(ts, us, color=color)
    ax2.tick_params(axis=&#39;y&#39;, labelcolor=color)
    ax2.set_ylim([min(us) - (0.1 * max(us)), 10 * max(us)])

    fig.tight_layout()  # otherwise the right y-label is slightly clipped
    plt.show()

  def diagnostics(self, plot=True):
    &#34;&#34;&#34;
    Perform diagnostics on the model&#39;s residuals and input data.

    This method calculates and prints the mean squared values of the 
    autocorrelation and cross-correlation functions of the residuals 
    and their differences. Optionally, it plots these diagnostics.

    Args:
      plot (bool, optional): If True, plots the diagnostics. Default is True.

    Attributes:
      cc_means (dict): A dictionary containing the mean squared values of the 
      autocorrelation and cross-correlation functions:
        - &#34;acf&#34;: Autocorrelation of residuals
        - &#34;ccf&#34;: Cross-correlation of residuals with input
        - &#34;acfd&#34;: Autocorrelation of residual differences
        - &#34;ccfd&#34;: Cross-correlation of residual differences with input

    Prints:
      Mean absolute values of the autocorrelation and cross-correlation 
      functions.

    Plots:
      If plot is True, generates the following plots:
        - Residuals
        - Autocorrelation of residuals
        - Cross-correlation of residuals with input
        - Residual differences
        - Autocorrelation of residual differences
        - Cross-correlation of residual differences with input
    &#34;&#34;&#34;
    t = self.Data.ts
    dt = t[1] - t[0]
    resid = self.result.resid
    res_norm = resid / np.linalg.norm(resid)
    u_norm = self.Data.u / np.linalg.norm(self.Data.u)

    resd = np.diff(resid)
    resd_norm = np.diff(resd) / np.linalg.norm(np.diff(resd))

    acf = np.correlate(res_norm, res_norm, &#39;same&#39;)
    acf[len(acf) // 2] = 0
    ccf = np.correlate(u_norm, res_norm, &#39;same&#39;)

    acfd = np.correlate(resd_norm, resd_norm, &#39;same&#39;)
    acfd[len(acfd) // 2] = 0
    ccfd = np.correlate(u_norm, resd_norm, &#39;same&#39;)

    self.cc_means = dict({&#34;acf&#34;: np.mean(acf ** 2), &#34;ccf&#34;: np.mean(ccf ** 2), &#34;acfd&#34;: np.mean(acfd ** 2), &#34;ccfd&#34;: np.mean(ccfd ** 2)})

    print(f&#34;Residual ACF:{np.mean(acf ** 2):0.3f}, CCF:{np.mean(ccf ** 2):0.3f}, ACFD:{np.mean(acfd ** 2):0.3f}, CCFD:{np.mean(ccfd ** 2):0.3f}&#34;)

    if plot:
      plt.subplots(3, 2)
      plt.subplot(321)
      plt.plot(resid)
      plt.title(&#34;Residuals&#34;)
      plt.grid()

      plt.subplot(323)
      plt.title(&#34;Autocorrelation of Residuals&#34;)
      plt.plot(acf)
      plt.ylim([-1, 1])
      plt.grid()

      plt.subplot(325)
      plt.title(&#34;Cross-correlation: Residuals -&gt; input&#34;)
      plt.plot(ccf)

      plt.ylim([-1, 1])
      plt.grid()

      plt.subplot(322)
      plt.plot(resd)
      plt.title(&#34;Residual diff&#34;)
      plt.grid()

      plt.subplot(324)
      plt.title(&#34;Autocorrelation of Residual diff&#34;)
      plt.plot(acfd)
      plt.ylim([-1, 1])
      plt.grid()

      plt.subplot(326)
      plt.title(&#34;Cross-correlation: Residual diff -&gt; input&#34;)
      plt.plot(ccfd)
      plt.ylim([-1, 1])
      plt.grid()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pydynamics.process_models.FOPDT" href="#pydynamics.process_models.FOPDT">FOPDT</a></li>
<li><a title="pydynamics.process_models.SOPDT" href="#pydynamics.process_models.SOPDT">SOPDT</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pydynamics.process_models.ProcessModel.ttest"><code class="name flex">
<span>def <span class="ident">ttest</span></span>(<span>mu1, sigma1, n1, mu2, sigma2, n2) â€‘>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a two-sample t-test for the difference between two means.</p>
<p>To be used to compare a parameter estimate from two different models / datasets (e.g. c_toi vs r_toi).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mu1</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean of the first sample.</dd>
<dt><strong><code>sigma1</code></strong> :&ensp;<code>float</code></dt>
<dd>Standard deviation of the first sample.</dd>
<dt><strong><code>n1</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of datapoints from the first sample.</dd>
<dt><strong><code>mu2</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean of the second sample.</dd>
<dt><strong><code>sigma2</code></strong> :&ensp;<code>float</code></dt>
<dd>Standard deviation of the second sample.</dd>
<dt><strong><code>n2</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of datapoints for the second sample.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>t-stat (float): The calculated t-value for the two-sample t-test.
p-value (float): The calculated p-value for the two-sample t-test.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ttest(mu1, sigma1, n1, mu2, sigma2, n2) -&gt; float:
  &#34;&#34;&#34;
  Perform a two-sample t-test for the difference between two means.

  To be used to compare a parameter estimate from two different models / datasets (e.g. c_toi vs r_toi).

  Args:
    mu1 (float): Mean of the first sample.
    sigma1 (float): Standard deviation of the first sample.
    n1 (int): Number of datapoints from the first sample.
    mu2 (float): Mean of the second sample.
    sigma2 (float): Standard deviation of the second sample.
    n2 (int): Number of datapoints for the second sample.

  Returns:
    t-stat (float): The calculated t-value for the two-sample t-test.
    p-value (float): The calculated p-value for the two-sample t-test.
  &#34;&#34;&#34;
  t_value = (mu1 - mu2) / np.sqrt(sigma1 ** 2 / n1 + sigma2 ** 2 / n2)
  p_value = 2 * (1 - stats.t.cdf(np.abs(t_value), n1 + n2 - 2))

  return t_value, p_value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pydynamics.process_models.ProcessModel.diagnostics"><code class="name flex">
<span>def <span class="ident">diagnostics</span></span>(<span>self, plot=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform diagnostics on the model's residuals and input data.</p>
<p>This method calculates and prints the mean squared values of the
autocorrelation and cross-correlation functions of the residuals
and their differences. Optionally, it plots these diagnostics.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, plots the diagnostics. Default is True.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>cc_means</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing the mean squared values of the </dd>
</dl>
<p>autocorrelation and cross-correlation functions:
- "acf": Autocorrelation of residuals
- "ccf": Cross-correlation of residuals with input
- "acfd": Autocorrelation of residual differences
- "ccfd": Cross-correlation of residual differences with input</p>
<h2 id="prints">Prints</h2>
<p>Mean absolute values of the autocorrelation and cross-correlation
functions.</p>
<h2 id="plots">Plots</h2>
<p>If plot is True, generates the following plots:
- Residuals
- Autocorrelation of residuals
- Cross-correlation of residuals with input
- Residual differences
- Autocorrelation of residual differences
- Cross-correlation of residual differences with input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagnostics(self, plot=True):
  &#34;&#34;&#34;
  Perform diagnostics on the model&#39;s residuals and input data.

  This method calculates and prints the mean squared values of the 
  autocorrelation and cross-correlation functions of the residuals 
  and their differences. Optionally, it plots these diagnostics.

  Args:
    plot (bool, optional): If True, plots the diagnostics. Default is True.

  Attributes:
    cc_means (dict): A dictionary containing the mean squared values of the 
    autocorrelation and cross-correlation functions:
      - &#34;acf&#34;: Autocorrelation of residuals
      - &#34;ccf&#34;: Cross-correlation of residuals with input
      - &#34;acfd&#34;: Autocorrelation of residual differences
      - &#34;ccfd&#34;: Cross-correlation of residual differences with input

  Prints:
    Mean absolute values of the autocorrelation and cross-correlation 
    functions.

  Plots:
    If plot is True, generates the following plots:
      - Residuals
      - Autocorrelation of residuals
      - Cross-correlation of residuals with input
      - Residual differences
      - Autocorrelation of residual differences
      - Cross-correlation of residual differences with input
  &#34;&#34;&#34;
  t = self.Data.ts
  dt = t[1] - t[0]
  resid = self.result.resid
  res_norm = resid / np.linalg.norm(resid)
  u_norm = self.Data.u / np.linalg.norm(self.Data.u)

  resd = np.diff(resid)
  resd_norm = np.diff(resd) / np.linalg.norm(np.diff(resd))

  acf = np.correlate(res_norm, res_norm, &#39;same&#39;)
  acf[len(acf) // 2] = 0
  ccf = np.correlate(u_norm, res_norm, &#39;same&#39;)

  acfd = np.correlate(resd_norm, resd_norm, &#39;same&#39;)
  acfd[len(acfd) // 2] = 0
  ccfd = np.correlate(u_norm, resd_norm, &#39;same&#39;)

  self.cc_means = dict({&#34;acf&#34;: np.mean(acf ** 2), &#34;ccf&#34;: np.mean(ccf ** 2), &#34;acfd&#34;: np.mean(acfd ** 2), &#34;ccfd&#34;: np.mean(ccfd ** 2)})

  print(f&#34;Residual ACF:{np.mean(acf ** 2):0.3f}, CCF:{np.mean(ccf ** 2):0.3f}, ACFD:{np.mean(acfd ** 2):0.3f}, CCFD:{np.mean(ccfd ** 2):0.3f}&#34;)

  if plot:
    plt.subplots(3, 2)
    plt.subplot(321)
    plt.plot(resid)
    plt.title(&#34;Residuals&#34;)
    plt.grid()

    plt.subplot(323)
    plt.title(&#34;Autocorrelation of Residuals&#34;)
    plt.plot(acf)
    plt.ylim([-1, 1])
    plt.grid()

    plt.subplot(325)
    plt.title(&#34;Cross-correlation: Residuals -&gt; input&#34;)
    plt.plot(ccf)

    plt.ylim([-1, 1])
    plt.grid()

    plt.subplot(322)
    plt.plot(resd)
    plt.title(&#34;Residual diff&#34;)
    plt.grid()

    plt.subplot(324)
    plt.title(&#34;Autocorrelation of Residual diff&#34;)
    plt.plot(acfd)
    plt.ylim([-1, 1])
    plt.grid()

    plt.subplot(326)
    plt.title(&#34;Cross-correlation: Residual diff -&gt; input&#34;)
    plt.plot(ccfd)
    plt.ylim([-1, 1])
    plt.grid()</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.estimate_confidence_intervals"><code class="name flex">
<span>def <span class="ident">estimate_confidence_intervals</span></span>(<span>self, p_cov)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute 95% confidence intervals of MLE parameters from the covariance matrix.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p_cov</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Covariance matrix of the parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of tuples containing the lower and upper bounds of the confidence intervals for each parameter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_confidence_intervals(self, p_cov):
  &#34;&#34;&#34;
  Compute 95% confidence intervals of MLE parameters from the covariance matrix.

  Args:
    p_cov (np.ndarray): Covariance matrix of the parameters.

  Returns:
    list: List of tuples containing the lower and upper bounds of the confidence intervals for each parameter.
  &#34;&#34;&#34;
  se = np.sqrt(np.diag(p_cov))
  p_opt = self.result.p_opt

  # 95% Confidence intervals
  confidence_intervals = []

  for i in range(len(p_opt)):
    lower = p_opt[i] - 1.96 * se[i]
    upper = p_opt[i] + 1.96 * se[i]
    confidence_intervals.append((lower, upper))
  return confidence_intervals</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.estimate_covariance"><code class="name flex">
<span>def <span class="ident">estimate_covariance</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate the covariance matrix of the parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>array-like</code></dt>
<dd>The parameters for which the covariance matrix is to be estimated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code> or <code>None</code></dt>
<dd>The estimated covariance matrix of the parameters. If the Jacobian is singular,</dd>
</dl>
<p>returns None and prints an error message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_covariance(self, params):
  &#34;&#34;&#34;
  Estimate the covariance matrix of the parameters.

  Args:
    params (array-like): The parameters for which the covariance matrix is to be estimated.

  Returns:
    np.ndarray or None: The estimated covariance matrix of the parameters. If the Jacobian is singular,
    returns None and prints an error message.
  &#34;&#34;&#34;
  res = self.result.resid
  sigma2 = np.sum(res ** 2) / (len(self.Data.ts) - len(params))
  J = self.jacobian(params)

  # Covariance matrix
  try:
    C = sigma2 * np.linalg.inv(J.T @ J)
  except np.linalg.LinAlgError:
    print(&#34;Jacobian is singular. Cannot compute confidence intervals.&#34;)
    return None

  return C</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.fit_model"><code class="name flex">
<span>def <span class="ident">fit_model</span></span>(<span>self, plot_result=False, plot_diagnostics=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Fits the model to the data, computes residuals, RMSE, R-squared value, and parameter statistics.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plot_result</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, plots the model results. Default is False.</dd>
<dt><strong><code>plot_diagnostics</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, plots diagnostic information. Default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pydynamics.process_models.Result" href="#pydynamics.process_models.Result">Result</a></code></dt>
<dd>An object containing the fitted parameters, their covariance, p-values, R-squared value, </dd>
</dl>
<p>model predictions, residuals, and RMSE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_model(self, plot_result=False, plot_diagnostics=False):
  &#34;&#34;&#34;
  Fits the model to the data, computes residuals, RMSE, R-squared value, and parameter statistics.

  Args:
    plot_result (bool, optional): If True, plots the model results. Default is False.
    plot_diagnostics (bool, optional): If True, plots diagnostic information. Default is False.

  Returns:
    Result: An object containing the fitted parameters, their covariance, p-values, R-squared value, 
    model predictions, residuals, and RMSE.
  &#34;&#34;&#34;
  p_opt = self.fit_params()  # fit the model
  y_hat = self.simulate(p_opt, self.Data.ts, self.Data.u)  # generate model predictions
  resid = self.Data.y - y_hat  # compute residuals
  rmse = np.sqrt(np.sum(resid ** 2) / len(self.Data.y))  # compute RMSE
  r_square = 1 - (np.var(self.Data.y - y_hat) / np.var(self.Data.y))  # compute R-squared value
  self.result = Result(p_opt=p_opt, p_cov=None, p_val=None, r_square=r_square, y_hat=y_hat, resid=resid, RMSE=rmse)
  p_cov = self.estimate_covariance(p_opt)
  p_val = self.pvalue(p_opt, p_cov)
  self.result = Result(p_opt=p_opt, p_cov=p_cov, p_val=p_val, r_square=r_square, y_hat=y_hat, resid=resid, RMSE=rmse)

  if plot_result:
    self.plot_results()

  if plot_diagnostics:
    self.diagnostics()
  return self.result</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.fit_params"><code class="name flex">
<span>def <span class="ident">fit_params</span></span>(<span>self, init_guess=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fit the parameters of the model using optimization.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>init_guess</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>Initial guess for the parameters. If None, an array of ones with the same shape as <code>self.params</code> is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>p_opt (array-like): Optimized parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_params(self, init_guess=None):
  &#34;&#34;&#34;
  Fit the parameters of the model using optimization.

  Args:
    init_guess (array-like, optional): Initial guess for the parameters. If None, an array of ones with the same shape as `self.params` is used.

  Returns:
    p_opt (array-like): Optimized parameters.
  &#34;&#34;&#34;
  if init_guess is None:
    init_guess = np.ones(self.params.shape)
  solution = minimize(self.objective, init_guess, bounds=self.bounds)
  p_opt = solution.x
  return p_opt</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.jacobian"><code class="name flex">
<span>def <span class="ident">jacobian</span></span>(<span>self, params) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Jacobian matrix of the model with respect to the parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>array-like</code></dt>
<dd>The parameters for which the Jacobian is to be computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The Jacobian matrix.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jacobian(self, params) -&gt; np.ndarray:
  &#34;&#34;&#34;
  Compute the Jacobian matrix of the model with respect to the parameters.

  Args:
    params (array-like): The parameters for which the Jacobian is to be computed.

  Returns:
    np.ndarray: The Jacobian matrix.
  &#34;&#34;&#34;
  K, tau, theta = params
  uf = interp1d(self.Data.ts, self.Data.u, fill_value=&#34;extrapolate&#34;)
  J = np.zeros((len(self.Data.ts), 3))
  dt = self.Data.ts[1] - self.Data.ts[0]

  for i, t in enumerate(self.Data.ts):
    if t - theta &lt;= 0:
      u_delayed = 0
      u_derivative = 0
    else:
      u_delayed = uf(t - theta)
      u_derivative = (uf(t - theta + dt) - uf(t - theta)) / dt

    J[i, 0] = u_delayed / tau
    J[i, 1] = -(K * u_delayed - self.Data.y[i]) / tau ** 2
    J[i, 2] = -(K / tau) * u_derivative

  return J</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.objective"><code class="name flex">
<span>def <span class="ident">objective</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the objective function value for given parameters.</p>
<p>This function simulates the model with the provided parameters and computes
the sum of squared differences between the simulated output and the actual data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>array-like</code></dt>
<dd>The parameters to be used for simulation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The sum of squared differences between the simulated output and the actual data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def objective(self, params):
  &#34;&#34;&#34;
  Calculate the objective function value for given parameters.

  This function simulates the model with the provided parameters and computes
  the sum of squared differences between the simulated output and the actual data.

  Args:
    params (array-like): The parameters to be used for simulation.

  Returns:
    float: The sum of squared differences between the simulated output and the actual data.
  &#34;&#34;&#34;
  ym = self.simulate(params)
  return np.sum((ym - self.Data.y) ** 2)</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.plot_confidence_intervals"><code class="name flex">
<span>def <span class="ident">plot_confidence_intervals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the observed data, the best fit model, and the 95% confidence intervals for the model predictions.</p>
<p>This method uses the time series data, the observed response, and the predicted response from the model.
It calculates the confidence intervals based on the covariance of the parameter estimates and simulates
the response using the lower and upper bounds of the confidence intervals. The plot includes the observed
data points, the best fit model line, and a shaded area representing the 95% confidence interval.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_confidence_intervals(self):
  &#34;&#34;&#34;
  Plots the observed data, the best fit model, and the 95% confidence intervals for the model predictions.

  This method uses the time series data, the observed response, and the predicted response from the model.
  It calculates the confidence intervals based on the covariance of the parameter estimates and simulates
  the response using the lower and upper bounds of the confidence intervals. The plot includes the observed
  data points, the best fit model line, and a shaded area representing the 95% confidence interval.
  &#34;&#34;&#34;
  t = self.Data.ts
  u = self.Data.u
  y_true = self.Data.y  # Observed data
  y_pred = self.result.y_hat
  params = self.result.p_opt
  ci = self.ci_from_cov(self.result.p_cov)

  # Simulate using confidence interval bounds
  params_lower = [ci[i][0] for i in range(len(params))]
  params_upper = [ci[i][1] for i in range(len(params))]
  y_lower = self.simulate(params_lower, self.Data.ts, self.Data.u)
  y_upper = self.simulate(params_upper, self.Data.ts, self.Data.u)

  plt.figure(figsize=(8, 5))
  plt.plot(t, y_true, &#39;ko&#39;, markersize=3, label=&#34;Observed Data&#34;)
  plt.plot(t, y_pred, &#39;r-&#39;, label=&#34;Best Fit Model&#34;)
  plt.fill_between(t, y_lower, y_upper, color=&#39;red&#39;, alpha=0.3, label=&#34;95% Confidence Interval&#34;)

  plt.xlabel(&#34;Time (s)&#34;)
  plt.ylabel(&#34;Response y(t)&#34;)
  plt.title(&#34;Model Fit with Confidence Interval&#34;)
  plt.legend()
  plt.grid(True)
  plt.show()</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.plot_results"><code class="name flex">
<span>def <span class="ident">plot_results</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the results of the model fit, including the observed data, model predictions,
and prediction intervals.</p>
<p>This method generates a plot with two y-axes:
- The left y-axis shows the change in output with observed data points, model predictions,
and prediction intervals.
- The right y-axis shows the change in input over time.</p>
<p>The plot includes:
- A title displaying the R-squared value and RMSE of the model fit.
- Observed data points as blue dots.
- Model predictions as a black line.
- 95% prediction intervals as a shaded red area.
- Standard error of the mean (SEM) intervals as a shaded red area with higher opacity.
- Change in input as a gray line (right axis).</p>
<p>The method also adjusts the layout to ensure the right y-label is not clipped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_results(self):
  &#34;&#34;&#34;
  Plots the results of the model fit, including the observed data, model predictions, 
  and prediction intervals.

  This method generates a plot with two y-axes:
  - The left y-axis shows the change in output with observed data points, model predictions, 
    and prediction intervals.
  - The right y-axis shows the change in input over time.

  The plot includes:
  - A title displaying the R-squared value and RMSE of the model fit.
  - Observed data points as blue dots.
  - Model predictions as a black line.
  - 95% prediction intervals as a shaded red area.
  - Standard error of the mean (SEM) intervals as a shaded red area with higher opacity.
  - Change in input as a gray line (right axis).

  The method also adjusts the layout to ensure the right y-label is not clipped.
  &#34;&#34;&#34;
  # gather variables
  ts, ys, us = self.Data
  res = self.result

  # calculate prediction intervals
  sem = np.sqrt(np.sum((res.resid) ** 2) / (len(ys) - 3))
  pi95 = 1.96 * sem

  fig, ax1 = plt.subplots(figsize=(8, 6))
  plt.title(f&#34;Model fit: Rsq = {res.r_square:0.3f}, RMSE = {res.RMSE:0.3f}&#34;)

  color = &#39;tab:blue&#39;
  ax1.set_xlabel(&#39;time&#39;)
  ax1.set_ylabel(&#39;Change in output&#39;, color=color)
  ax1.fill_between(ts, res.y_hat - pi95, res.y_hat + pi95, color=&#39;r&#39;, alpha=0.15, label=&#39;95% PI&#39;)
  ax1.fill_between(ts, res.y_hat - sem, res.y_hat + sem, color=&#39;r&#39;, alpha=0.2, label=&#39;SE PI&#39;)
  ax1.plot(ts, ys, &#39;b.&#39;, label=&#39;observations&#39;, alpha=0.6)
  ax1.plot(ts, res.y_hat, &#39;k&#39;, linewidth=1.5, label=&#39;model&#39;)
  ax1.tick_params(axis=&#39;y&#39;, labelcolor=color)
  ax1.legend(loc=&#39;upper left&#39;)
  ax1.grid()

  ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
  color = &#39;tab:gray&#39;
  ax2.set_ylabel(&#39;Change in input&#39;, color=color)  # we already handled the x-label with ax1
  ax2.plot(ts, us, color=color)
  ax2.tick_params(axis=&#39;y&#39;, labelcolor=color)
  ax2.set_ylim([min(us) - (0.1 * max(us)), 10 * max(us)])

  fig.tight_layout()  # otherwise the right y-label is slightly clipped
  plt.show()</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.pvalue"><code class="name flex">
<span>def <span class="ident">pvalue</span></span>(<span>self, params, p_cov)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the p-values for the model parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Model parameters.</dd>
<dt><strong><code>p_cov</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Covariance matrix of the parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Array of p-values for each parameter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pvalue(self, params, p_cov):
  &#34;&#34;&#34;
  Compute the p-values for the model parameters.

  Args:
    params (np.ndarray): Model parameters.
    p_cov (np.ndarray): Covariance matrix of the parameters.

  Returns:
    np.ndarray: Array of p-values for each parameter.
  &#34;&#34;&#34;
  se = np.sqrt(np.diag(p_cov))
  t_values = params / se
  p_values = 2 * (1 - stats.t.cdf(np.abs(t_values), len(self.Data.ts) - len(params)))
  return p_values</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.save_model"><code class="name flex">
<span>def <span class="ident">save_model</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the model object to a file using pickle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the file to save the model object to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_model(self, filename):
  &#34;&#34;&#34;
  Save the model object to a file using pickle.

  Args:
    filename (str): The name of the file to save the model object to.

  Returns:
    None
  &#34;&#34;&#34;
  with open(filename, &#39;wb&#39;) as file:
    pickle.dump(self, file)</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.ProcessModel.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, params=None, step=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a step response plot for a First Order Plus Dead Time (FOPDT) model with the given parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>list</code> or <code>None</code></dt>
<dd>Parameters for the FOPDT model. If None, uses self.result.p_opt.</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>int</code></dt>
<dd>The step input value. Default is 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>This function generates and displays a plot.</dd>
</dl>
<p>The function performs the following steps:
1. If params is None, it assigns self.result.p_opt to params.
2. Extracts the time constant (taum) from params.
3. Creates a time array (ts) ranging from -taum to 5 * taum.
4. Initializes an input array (us) with zeros and sets the step input after taum.
5. Simulates the FOPDT model response using the given parameters, time array, and input array.
6. Plots the output response and input signal on two subplots.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, params=None, step=1):
  &#34;&#34;&#34;
  Generate a step response plot for a First Order Plus Dead Time (FOPDT) model with the given parameters.

  Args:
    params (list or None): Parameters for the FOPDT model. If None, uses self.result.p_opt.
    step (int): The step input value. Default is 1.

  Returns:
    None: This function generates and displays a plot.

  The function performs the following steps:
  1. If params is None, it assigns self.result.p_opt to params.
  2. Extracts the time constant (taum) from params.
  3. Creates a time array (ts) ranging from -taum to 5 * taum.
  4. Initializes an input array (us) with zeros and sets the step input after taum.
  5. Simulates the FOPDT model response using the given parameters, time array, and input array.
  6. Plots the output response and input signal on two subplots.
  &#34;&#34;&#34;
  if params is None:
    params = self.result.p_opt
  taum = params[1]
  ts = np.arange(-taum, 5 * taum)

  us = np.zeros((len(ts)))
  us[np.int8(taum) + 1:] = step

  y = self.simulate(params, ts, us)
  plt.figure()
  plt.subplots(2, 1, sharex=True)

  plt.subplot(211)
  plt.plot(ts, y)
  plt.grid()
  plt.ylabel(&#34;Output&#34;)
  plt.subplot(212)
  plt.ylabel(&#34;Input&#34;)
  plt.plot(ts, us)
  plt.grid()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pydynamics.process_models.Result"><code class="flex name class">
<span>class <span class="ident">Result</span></span>
<span>(</span><span>p_opt, p_cov, p_val, r_square, y_hat, resid, RMSE)</span>
</code></dt>
<dd>
<div class="desc"><p>A result container for process model fitting. Contains the optimized parameters, covariance, p-values, R-squared value, model predictions, residuals, and RMSE.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>p_opt</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Optimized parameters.</dd>
<dt><strong><code>p_cov</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Covariance matrix of the parameters.</dd>
<dt><strong><code>p_val</code></strong> :&ensp;<code>array-like</code></dt>
<dd>P-values of the parameters.</dd>
<dt><strong><code>r_square</code></strong> :&ensp;<code>float</code></dt>
<dd>R-squared value of the model fit.</dd>
<dt><strong><code>y_hat</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Model predictions.</dd>
<dt><strong><code>resid</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Residuals of the model fit.</dd>
<dt><strong><code>RMSE</code></strong> :&ensp;<code>float</code></dt>
<dd>Root Mean Squared Error of the model fit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Result:
  &#34;&#34;&#34;
  A result container for process model fitting. Contains the optimized parameters, covariance, p-values, R-squared value, model predictions, residuals, and RMSE.
  
  Attributes:
    p_opt (array-like): Optimized parameters.
    p_cov (array-like): Covariance matrix of the parameters.
    p_val (array-like): P-values of the parameters.
    r_square (float): R-squared value of the model fit.
    y_hat (array-like): Model predictions.
    resid (array-like): Residuals of the model fit.
    RMSE (float): Root Mean Squared Error of the model fit.
  &#34;&#34;&#34;
  def __init__(self, p_opt, p_cov, p_val, r_square, y_hat, resid, RMSE):
    self.p_opt = p_opt
    self.p_cov = p_cov
    self.p_val = p_val
    self.r_square = r_square
    self.y_hat = y_hat
    self.resid = resid
    self.RMSE = RMSE

  def __repr__(self):
    return f&#34;Result(p_opt={self.p_opt}, p_val={self.p_val}, r_square={self.r_square}, RMSE={self.RMSE})&#34;

  def __str__(self):
    return f&#34;Result(p_opt={self.p_opt}, p_val={self.p_val}, r_square={self.r_square}, RMSE={self.RMSE})&#34;</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.SOPDT"><code class="flex name class">
<span>class <span class="ident">SOPDT</span></span>
<span>(</span><span>t, y, u, params=array([1., 1., 1., 1.]))</span>
</code></dt>
<dd>
<div class="desc"><p>Base model class that handles the fitting and plotting for various process models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>Data</code></strong> :&ensp;<code><a title="pydynamics.process_models.Data" href="#pydynamics.process_models.Data">Data</a></code></dt>
<dd>An instance of the Data class containing time (t), output (y), and input (u) data.</dd>
<dt><strong><code>uf</code></strong> :&ensp;<code>interp1d</code></dt>
<dd>Interpolated function of the input data.</dd>
</dl>
<p>Initialize the process model with time, output, and input data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Array of time points.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Array of output data corresponding to the time points.</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Array of input data corresponding to the time points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SOPDT(ProcessModel):
  def __init__(self, t, y, u, params=np.ones((4,))):
    super(SOPDT, self).__init__(t, y, u)
    self.params = params
    self.bounds = [(-np.inf, np.inf), (0.01, np.inf), (0.01, np.inf), (0, np.inf)]

  def model(self, x, t, uf, Kp, taus, zeta, thetap):
    
    # Kp = process gain
    # taus = second order time constant
    # zeta = damping factor
    # thetap = model time delay
    # equation: ts^2 dy2/dt2 + 2 zeta taus dydt + y = Kp * u(t-thetap)

    u0 = 0
    try:
      if (t - thetap) &lt;= 0:
        um = 0
      else:
        um = uf(t - thetap)
    except:
      # catch any error
      um = 0
    # two states (y and y&#39;)
    y = x[0]
    dydt = x[1]
    dy2dt2 = (-2.0 * zeta * taus * dydt - y + Kp * (um)) / taus ** 2
    return [dydt, dy2dt2]

  # simulate model with x=[Km, taum, zetam, thetam]
  def simulate(self, params=None):
    &#34;&#34;&#34;
    Simulate the system using the given parameters.

    Parameters:
    params (tuple, optional): A tuple containing the parameters (Kp, taus, zeta, thetap) 
                  for the simulation. If None, self.params will be used.
    
    Returns:
    numpy.ndarray: The simulated output values over time.
    &#34;&#34;&#34;
    if params is None:
      params = self.params
    Kp, taus, zeta, thetap = params

    uf = self.uf
    t = self.Data.t
    # storage for model values
    xm = np.zeros((len(t), 2))  # model
    # initial condition
    xm[0] = 0
    # loop through time steps
    for i in range(len(t) - 1):
      ts = [t[i], t[i + 1]]
      inputs = (uf, Kp, taus, zeta, thetap)
      # integrate SOPDT model
      x = odeint(self.model, xm[i], ts, args=inputs)
      xm[i + 1] = x[-1]
    y = xm[:, 0]
    return y</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pydynamics.process_models.ProcessModel" href="#pydynamics.process_models.ProcessModel">ProcessModel</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pydynamics.process_models.SOPDT.model"><code class="name flex">
<span>def <span class="ident">model</span></span>(<span>self, x, t, uf, Kp, taus, zeta, thetap)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model(self, x, t, uf, Kp, taus, zeta, thetap):
  
  # Kp = process gain
  # taus = second order time constant
  # zeta = damping factor
  # thetap = model time delay
  # equation: ts^2 dy2/dt2 + 2 zeta taus dydt + y = Kp * u(t-thetap)

  u0 = 0
  try:
    if (t - thetap) &lt;= 0:
      um = 0
    else:
      um = uf(t - thetap)
  except:
    # catch any error
    um = 0
  # two states (y and y&#39;)
  y = x[0]
  dydt = x[1]
  dy2dt2 = (-2.0 * zeta * taus * dydt - y + Kp * (um)) / taus ** 2
  return [dydt, dy2dt2]</code></pre>
</details>
</dd>
<dt id="pydynamics.process_models.SOPDT.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, params=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate the system using the given parameters.</p>
<p>Parameters:
params (tuple, optional): A tuple containing the parameters (Kp, taus, zeta, thetap)
for the simulation. If None, self.params will be used.</p>
<p>Returns:
numpy.ndarray: The simulated output values over time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self, params=None):
  &#34;&#34;&#34;
  Simulate the system using the given parameters.

  Parameters:
  params (tuple, optional): A tuple containing the parameters (Kp, taus, zeta, thetap) 
                for the simulation. If None, self.params will be used.
  
  Returns:
  numpy.ndarray: The simulated output values over time.
  &#34;&#34;&#34;
  if params is None:
    params = self.params
  Kp, taus, zeta, thetap = params

  uf = self.uf
  t = self.Data.t
  # storage for model values
  xm = np.zeros((len(t), 2))  # model
  # initial condition
  xm[0] = 0
  # loop through time steps
  for i in range(len(t) - 1):
    ts = [t[i], t[i + 1]]
    inputs = (uf, Kp, taus, zeta, thetap)
    # integrate SOPDT model
    x = odeint(self.model, xm[i], ts, args=inputs)
    xm[i + 1] = x[-1]
  y = xm[:, 0]
  return y</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pydynamics.process_models.ProcessModel" href="#pydynamics.process_models.ProcessModel">ProcessModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pydynamics.process_models.ProcessModel.diagnostics" href="#pydynamics.process_models.ProcessModel.diagnostics">diagnostics</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.estimate_confidence_intervals" href="#pydynamics.process_models.ProcessModel.estimate_confidence_intervals">estimate_confidence_intervals</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.estimate_covariance" href="#pydynamics.process_models.ProcessModel.estimate_covariance">estimate_covariance</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.fit_model" href="#pydynamics.process_models.ProcessModel.fit_model">fit_model</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.fit_params" href="#pydynamics.process_models.ProcessModel.fit_params">fit_params</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.jacobian" href="#pydynamics.process_models.ProcessModel.jacobian">jacobian</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.objective" href="#pydynamics.process_models.ProcessModel.objective">objective</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.plot_confidence_intervals" href="#pydynamics.process_models.ProcessModel.plot_confidence_intervals">plot_confidence_intervals</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.plot_results" href="#pydynamics.process_models.ProcessModel.plot_results">plot_results</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.pvalue" href="#pydynamics.process_models.ProcessModel.pvalue">pvalue</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.save_model" href="#pydynamics.process_models.ProcessModel.save_model">save_model</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.step" href="#pydynamics.process_models.ProcessModel.step">step</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.ttest" href="#pydynamics.process_models.ProcessModel.ttest">ttest</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pydynamics" href="index.html">pydynamics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pydynamics.process_models.Data" href="#pydynamics.process_models.Data">Data</a></code></h4>
</li>
<li>
<h4><code><a title="pydynamics.process_models.FOPDT" href="#pydynamics.process_models.FOPDT">FOPDT</a></code></h4>
<ul class="">
<li><code><a title="pydynamics.process_models.FOPDT.model" href="#pydynamics.process_models.FOPDT.model">model</a></code></li>
<li><code><a title="pydynamics.process_models.FOPDT.simulate" href="#pydynamics.process_models.FOPDT.simulate">simulate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pydynamics.process_models.ProcessModel" href="#pydynamics.process_models.ProcessModel">ProcessModel</a></code></h4>
<ul class="">
<li><code><a title="pydynamics.process_models.ProcessModel.diagnostics" href="#pydynamics.process_models.ProcessModel.diagnostics">diagnostics</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.estimate_confidence_intervals" href="#pydynamics.process_models.ProcessModel.estimate_confidence_intervals">estimate_confidence_intervals</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.estimate_covariance" href="#pydynamics.process_models.ProcessModel.estimate_covariance">estimate_covariance</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.fit_model" href="#pydynamics.process_models.ProcessModel.fit_model">fit_model</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.fit_params" href="#pydynamics.process_models.ProcessModel.fit_params">fit_params</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.jacobian" href="#pydynamics.process_models.ProcessModel.jacobian">jacobian</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.objective" href="#pydynamics.process_models.ProcessModel.objective">objective</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.plot_confidence_intervals" href="#pydynamics.process_models.ProcessModel.plot_confidence_intervals">plot_confidence_intervals</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.plot_results" href="#pydynamics.process_models.ProcessModel.plot_results">plot_results</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.pvalue" href="#pydynamics.process_models.ProcessModel.pvalue">pvalue</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.save_model" href="#pydynamics.process_models.ProcessModel.save_model">save_model</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.step" href="#pydynamics.process_models.ProcessModel.step">step</a></code></li>
<li><code><a title="pydynamics.process_models.ProcessModel.ttest" href="#pydynamics.process_models.ProcessModel.ttest">ttest</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pydynamics.process_models.Result" href="#pydynamics.process_models.Result">Result</a></code></h4>
</li>
<li>
<h4><code><a title="pydynamics.process_models.SOPDT" href="#pydynamics.process_models.SOPDT">SOPDT</a></code></h4>
<ul class="">
<li><code><a title="pydynamics.process_models.SOPDT.model" href="#pydynamics.process_models.SOPDT.model">model</a></code></li>
<li><code><a title="pydynamics.process_models.SOPDT.simulate" href="#pydynamics.process_models.SOPDT.simulate">simulate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>